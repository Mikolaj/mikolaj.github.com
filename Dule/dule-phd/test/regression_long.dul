(* Copyright (C) 2003 Mikolaj Konarski
 *
 * This file is part of the Dule compiler.
 * The Dule compiler is released under the GNU General Public License (GPL).
 * Please see the file Dule-LICENSE for license information.
 *
 * $Id: regression_long.dul,v 1.21 2006-05-03 03:25:26 mikon Exp $
 *) 

(* Regression tests. Please ignore. *)

Lo_Base =  
link
spec Elem = sig type t end
spec List = 
~Elem ->
  sig
    type t
    value ind_list : ~l:t ->
      ind t: [`Nil|`Cons {head : Elem.t; tail : t}]
    value de_list : ~l:t -> [`Nil|`Cons {head : Elem.t; tail : t}]
    value nil : t
    value cons : ~head:Elem.t ~tail:t -> t
  end
library List =
  struct
    type t = ind t: [`Nil|`Cons {head : Elem.t; tail : t}]
    value ind_list = fun ~l -> l
    value de_list = fun ~l -> l . de
    value nil = `Nil . con
    value cons = fun ~head ~tail -> {head; tail} .`Cons . con
  end
spec EndoList = 
~List ->
  sig
    value foldr : ~init:List.t 
                  ~f: ~e:Elem.t ~r:List.t -> List.t 
                  ~l:List.t 
                    -> List.t
    value bmap : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
    value append : ~l1:List.t ~l2:List.t -> List.t 
    value is_nil : ~l:List.t -> [`True|`False]
  end
library EndoList =
  struct
    value foldr = 
      fun ~init ~f ~l -> 
        match List.ind_list ~l with
        fold [`Nil -> init
              |`Cons ht -> f ~e:ht.head ~r:ht.tail]
    value bmap = fun ~f ~l -> 
      match List.ind_list ~l with
      fold [`Nil -> List.nil
            |`Cons ht -> List.cons ~head:(f ~e:ht.head) ~tail:ht.tail]
    value append = fun ~l1 ~l2 ->
      match List.ind_list ~l:l1 with
      fold [`Nil -> l2
            |`Cons ht -> List.cons ~head:ht.head ~tail:ht.tail]
    value is_nil = fun ~l -> 
      match List.de_list ~l with
      [`Nil -> `True
      |`Cons -> `False]
  end

Base = 
link
spec Bool =
  sig
    value true_ : [`True|`False]
    value false_ : [`True|`False]
    value not_ : ~it:[`True|`False] -> [`True|`False] 
    value and_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
    value or_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
  end
Bool = 
  struct
    value true_ = `True
    value false_ = `False
    value not_ = [`True -> `False
                 |`False -> `True]
    value and_ = [`True fun ~b ~it -> b
                 |`False fun ~b ~it -> `False]
    value or_ = [`True fun ~b ~it -> `True
                |`False fun ~b ~it -> b]
  end
spec Char =
  sig 
    type t
    value de_char : ~c:t -> [`a|`b|`c
                            |`A|`B|`C
                            |`quote]
    value c_a : t
    value c_b : t
    value c_c : t
    value c_A : t
    value c_B : t
    value c_C : t
    value c_quote : t
    value upper : ~it:t -> t
    value lower : ~it:t -> t
    value eq : ~c:t ~it:t -> [`True|`False]
  end
Char =
  struct
    type t = [`a|`b|`c
             |`A|`B|`C
             |`quote]
    value de_char = fun ~c -> c
    value c_a = `a
    value c_b = `b
    value c_c = `c
    value c_A = `A
    value c_B = `B
    value c_C = `C
    value c_quote = `quote
    value upper = [`a -> `A|`b -> `B|`c -> `C
                  |`A -> `A|`B -> `B|`C -> `C
                  |`quote -> `quote]
    value lower = [`a -> `a|`b -> `b|`c -> `c
                  |`A -> `a|`B -> `b|`C -> `c
                  |`quote -> `quote]
    value eq =
      let true_ = `True
          false_ = `False 
      in
      [`a fun ~c ~it -> match c with 
        [`a -> true_|`b -> false_|`c -> false_
        |`A -> false_|`B -> false_|`C -> false_
        |`quote -> false_]
      |`b fun ~c ~it -> match c with 
        [`a -> false_|`b -> true_|`c -> false_
        |`A -> false_|`B -> false_|`C -> false_
        |`quote -> false_]
      |`c fun ~c ~it -> match c with 
        [`a -> false_|`b -> false_|`c -> true_
        |`A -> false_|`B -> false_|`C -> false_
        |`quote -> false_]
      |`A fun ~c ~it -> match c with
        [`a -> false_|`b -> false_|`c -> false_
        |`A -> true_|`B -> false_|`C -> false_
        |`quote -> false_]
      |`B fun ~c ~it -> match c with
        [`a -> false_|`b -> false_|`c -> false_
        |`A -> false_|`B -> true_|`C -> false_
        |`quote -> false_]
      |`C fun ~c ~it -> match c with
        [`a -> false_|`b -> false_|`c -> false_
        |`A -> false_|`B -> false_|`C -> true_
        |`quote -> false_]
      |`quote fun ~c ~it -> match c with
        [`a -> false_|`b -> false_|`c -> false_
        |`A -> false_|`B -> false_|`C -> false_
        |`quote -> true_]
      ] 
  end
spec CharList = List with {Elem = Char}
CharList = load List with {Elem = Char}
spec CharEndoList = EndoList with {Elem = Char; List = CharList}
CharEndoList = load EndoList with {Elem = Char; List = CharList}
spec String =
~CharEndoList ->
  sig
    value eq : ~l:CharList.t ~k:CharList.t -> [`True|`False]
    value up : CharList.t
    value it : CharList.t
    value a : Char.t
    value prefix_by_a : ~tail:CharList.t -> CharList.t
    value shout : ~l:CharList.t -> CharList.t
    value shout' : ~l:CharList.t -> 
      ind t: [`Nil|`Cons {head : Char.t; tail : t}]
  end
module String = 
  :: ~Bool -> String
  struct
    value eq =
      let non_nil_eq = fun ~ht -> fun ~l -> 
        match CharList.de_list ~l with
        [`Nil -> Bool.false_
        |`Cons kht ->
           let head_matches = Char.eq ~c:ht.head ~it:kht.head
               tail_equal = ht.tail ~l:kht.tail in
           Bool.and_ ~b:head_matches ~it:tail_equal]
      in
      fun ~l ~k -> 
        (match CharList.ind_list ~l with
         fold [`Nil -> CharEndoList.is_nil
              |`Cons fun ~it:ht -> non_nil_eq ~ht])
          ~l:k
    value up = CharList.cons ~head:Char.c_a 
                 ~tail:(CharList.cons ~head:Char.c_b
                          ~tail:CharList.nil)
    value it = CharList.cons ~head:Char.c_c 
                 ~tail:(CharList.cons ~head:Char.c_a 
                          ~tail:(CharList.cons ~head:Char.c_b
                                   ~tail:CharList.nil))
    value a = Char.c_a
    value prefix_by_a = fun ~tail -> 
      CharList.cons ~head:Char.c_a ~tail
    value shout = fun ~l -> 
      CharEndoList.bmap ~l ~f:fun ~e -> Char.upper ~it:e  
    value shout' = fun ~l -> 
      match CharList.ind_list ~l with
      map Char.upper
  end
end
spec Char =
  sig 
    type t
    value de_char : ~c:t -> [`a|`b|`c
                            |`A|`B|`C
                            |`quote]
    value c_a : t
    value c_b : t
    value c_c : t
    value c_A : t
    value c_B : t
    value c_C : t
    value c_quote : t
    value upper : ~it:t -> t
    value lower : ~it:t -> t
    value eq : ~c:t ~it:t -> [`True|`False]
  end
spec CharList = List with {Elem = Char}
spec CharEndoList = EndoList with {Elem = Char; List = CharList}
spec String =
~CharEndoList ->
  sig
    value eq : ~l:CharList.t ~k:CharList.t -> [`True|`False]
    value up : CharList.t
    value it : CharList.t
    value a : Char.t
    value prefix_by_a : ~tail:CharList.t -> CharList.t
    value shout : ~l:CharList.t -> CharList.t
    value shout' : ~l:CharList.t -> 
      ind t: [`Nil|`Cons {head : Char.t; tail : t}]
  end
Char = Base . Char
CharList = Base . CharList
CharEndoList = Base . CharEndoList
String = Base . String

spec Index =
  sig
    type t
    value eq : ~i:t ~j:t -> [`True|`False]
    value isDU : ~i:t -> [`True|`False]
    value up : t
    value it : t
    value ati : t
    value atj : t
    value att : t
    value atv : t
    value prim : ~i:t -> t
  end
Index =
  :: ~String -> Index
  struct
    type t = CharList.t
    value eq = fun ~i ~j -> String.eq ~l:i ~k:j
    value isDU = fun ~i -> `True
    value up = String.up
    value it = String.it
    value ati = String.up
    value atj = String.up
    value att = String.up
    value atv = String.up
    value prim = fun ~i -> 
      CharEndoList.append ~l1:i 
        ~l2:(CharList.cons ~head:Char.c_quote 
              ~tail:CharList.nil)
  end
spec Value = sig type t end
library AssocIList =
  link
    spec AssocIList = 
    ~Index ~Value ->
      sig
        type t
        value ind_ilist : ~l:t ->
          ind t: [`Nil|`Cons {i : Index.t; v : Value.t; l : t}]
        value nil : t
        value cons : ~i:Index.t ~v:Value.t ~l:t -> t
        value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
        value append : ~l1:t ~l2:t -> t
        value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
        value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
        value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
        value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
        value coi : ~ati:Value.t ~atj:Value.t -> t
      end
    spec Elem = 
    ~Index ~Value -> 
      sig
        type t
        value i : ~e:t -> Index.t
        value v : ~e:t -> Value.t
        value assoc : ~i:Index.t ~v:Value.t -> t
        value imatch : ~e:t ~i:Index.t -> [`OK Value.t |`Error]
      end
    Elem = 
      struct
        type t = {i : Index.t; v : Value.t}
        value i = fun ~e -> e.i
        value v = fun ~e -> e.v
        value assoc = fun ~i ~v -> {i; v}
        value imatch = fun ~e ~i -> 
          match Index.eq ~i ~j:e.i with
          [`True -> e.v .`OK
          |`False -> `Error] 
      end
    spec ElemList = List with {Elem}
    ElemList = load List with {Elem}
    spec ElemEndoList = EndoList with {{List = ElemList}}
    ElemEndoList = load EndoList with {{List = ElemList}}
    AssocIList = 
      :: ~ElemEndoList -> AssocIList
      struct
        type t = ElemList.t
        value ind_ilist = fun ~l -> 
          match ElemList.ind_list ~l with
          fold [`Nil -> `Nil . con
                |`Cons ht -> {i = Elem.i ~e:ht.head;
                              v = Elem.v ~e:ht.head;
                              l = ht.tail} .`Cons . con]
        value nil = ElemList.nil
        value cons = fun ~i ~v ~l -> 
          ElemList.cons ~tail:l ~head:(Elem.assoc ~i ~v)
        value find_ok = fun ~i ~l -> 
          let tail_or_in_head = fun ~it:ht ->
            match ht.tail with
            [`OK -> ht.tail
            |`Error -> Elem.imatch ~e:ht.head ~i]
          in
          match ElemList.ind_list ~l with
          fold [`Nil -> `Error
               |`Cons tail_or_in_head]
        value append = ElemEndoList.append
        value bmap = fun ~f ~l ->
          let bf = fun ~e ->
            let i = Elem.i ~e
                v = Elem.v ~e in
            Elem.assoc ~i ~v:(f ~i ~v)
          in
          ElemEndoList.bmap ~f:bf ~l
        value vmap = fun ~f ~l ->
          let bf = fun ~e ->
            let i = Elem.i ~e
                v = Elem.v ~e in
            Elem.assoc ~i ~v:(f ~v)
          in
          ElemEndoList.bmap ~f:bf ~l
        value imap = fun ~f ~l ->
          let bf = fun ~e ->
            let i = Elem.i ~e
                v = Elem.v ~e in
            Elem.assoc ~i ~v:(f ~i)
          in
          ElemEndoList.bmap ~f:bf ~l
        value ifilter = fun ~p ~l ->
          let f = fun ~e ~r ->
            let i = Elem.i ~e in
            match p ~i with
            [`True -> ElemList.cons ~head:e ~tail:r
            |`False -> r]
          in
          ElemEndoList.foldr ~init:ElemList.nil ~f ~l
        value coi = fun ~ati ~atj -> 
          ElemList.cons ~head:(Elem.assoc ~i:Index.ati ~v:ati)
            ~tail:(ElemList.cons ~head:(Elem.assoc ~i:Index.atj ~v:atj) 
                     ~tail:ElemList.nil)
      end
  end . AssocIList

Compiler = 
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value ind_ilist : ~l:t ->
        ind t: [`Nil|`Cons {i : Index.t; v : Value.t; l : t}]
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value append : ~l1:t ~l2:t -> t
      value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
      value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
      value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
      value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
      value coi : ~ati:Value.t ~atj:Value.t -> t
   end
  library IList = load AssocIList :> IList
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value de_cat : ~c:t ->
	       [`C_PP CatIList.t
               |`C_BB]
      value c_PP : ~lc:CatIList.t -> t
      value c_BB : t
    end
  module ind CatIList = load IList with {{Value = Cat}}
  and Cat = 
    struct
      type t = 
	ind t: [`C_PP CatIList.t
               |`C_BB]
      value de_cat = fun ~c -> c . de
      value c_PP = fun ~lc -> lc .`C_PP . con
      value c_BB = `C_BB . con
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
      value ind_funct : ~f:t -> 
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value de_funct : ~f:t -> 
               [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value f_ID : ~c:Cat.t -> t
      value f_COMP : ~f1:t ~f2:t -> t
      value f_PR : ~lc:CatIList.t ~i:Index.t -> t
      value f_RECORD : ~c:Cat.t ~lf:FunctIList.t -> t
      value f_pp : ~c:Cat.t ~lf:FunctIList.t -> t
      value f_ss : ~c:Cat.t ~lf:FunctIList.t -> t
      value f_ee : ~lf:FunctIList.t ~i:Index.t ~f:t -> t
      value f_ii : ~f:t -> t
      value f_tt : ~f:t -> t
    end
  module ind FunctIList = load IList with {{Value = Funct}}
  and Funct =
    struct
      type t =
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value ind_funct = fun ~f -> f
      value de_funct = fun ~f -> f . de
      value f_ID = fun ~c -> c .`F_ID . con
      value f_COMP = fun ~f1 ~f2 -> {f1; f2} .`F_COMP . con
      value f_PR = fun ~lc ~i -> {lc; i} .`F_PR . con
      value f_RECORD = fun ~c ~lf -> {c; lf} .`F_RECORD . con
      value f_pp = fun ~c ~lf -> {c; lf} .`F_pp . con
      value f_ss = fun ~c ~lf -> {c; lf} .`F_ss . con
      value f_ee = fun ~lf ~i ~f -> {lf; i; f} .`F_ee . con
      value f_ii = fun ~f -> f .`F_ii . con
      value f_tt = fun ~f -> f .`F_tt . con
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
      value t_ID : ~c:Cat.t -> t
      value t_COMP : ~t1:t ~t2:t -> t
      value t_PR : ~lc:CatIList.t ~i:Index.t -> t
      value t_RECORD : ~c:Cat.t ~lt:TransIList.t -> t
      value t_pp : ~c:Cat.t ~lt:TransIList.t -> t
      value t_ss : ~c:Cat.t ~lt:TransIList.t -> t
      value t_ee : ~lt:TransIList.t ~i:Index.t ~t:t -> t
      value t_ii : ~t:t -> t
      value t_tt : ~t:t -> t
      value t_id : ~f:Funct.t -> t
      value t_comp : ~t1:t ~t2:t -> t
      value t_pr : ~lf:FunctIList.t ~i:Index.t -> t
      value t_record : ~f:Funct.t ~lt:TransIList.t -> t
      value t_in : ~lf:FunctIList.t ~i:Index.t -> t
      value t_case : ~lt:TransIList.t ~h:Funct.t  -> t
      value tl_case : ~f:Funct.t ~lt:TransIList.t ~h:Funct.t -> t
      value t_appl : ~lf:FunctIList.t ~i:Index.t ~f:Funct.t -> t
      value t_curry : ~i:Index.t ~t:t -> t
      value tl_map : ~f:Funct.t ~t:t -> t
      value t_con : ~f:Funct.t -> t
      value t_fold : ~f:Funct.t ~t:t -> t
      value tl_fold : ~f:Funct.t ~t:t -> t
      value tl_de : ~f:Funct.t -> t
      value t_de : ~f:Funct.t -> t
      value t_unfold : ~f:Funct.t ~t:t -> t
      value tl_unfold : ~f:Funct.t ~t:t -> t
      value tl_con : ~f:Funct.t -> t
      value t_fix : ~t:t -> t
      value tl_fix : ~t:t -> t
    end
  module ind TransIList = load IList with {{Value = Trans}}
  and Trans = 
    struct
      type t = 
        ind t: [`T_ID Cat.t
	       |`T_COMP {t1 : t; t2 : t}
	       |`T_PR {lc : CatIList.t; i : Index.t}
	       |`T_RECORD {c : Cat.t; lt : TransIList.t}
	       |`T_pp {c : Cat.t; lt : TransIList.t}
	       |`T_ss {c : Cat.t; lt : TransIList.t}
	       |`T_ee {lt : TransIList.t; i : Index.t; t : t}
	       |`T_ii t
	       |`T_tt t
	       |`T_id Funct.t
	       |`T_comp {t1 : t; t2 : t} 
	       |`T_pr {lf : FunctIList.t; i : Index.t}
	       |`T_record {f : Funct.t; lt : TransIList.t}
	       |`T_in {lf : FunctIList.t; i : Index.t}
	       |`T_case {lt : TransIList.t; h : Funct.t}
	       |`TL_case {f : Funct.t; lt : TransIList.t; h : Funct.t}
	       |`T_appl {lf : FunctIList.t; i : Index.t; f : Funct.t}
	       |`T_curry {i : Index.t; t : t}
	       |`TL_map {f : Funct.t; t : t}
	       |`T_con Funct.t
	       |`T_fold {f : Funct.t; t : t}
	       |`TL_fold {f : Funct.t; t : t}
	       |`TL_de Funct.t
	       |`T_de Funct.t
	       |`T_unfold {f : Funct.t; t :t}
	       |`TL_unfold {f : Funct.t; t :t}
	       |`TL_con Funct.t
	       |`T_fix t
	       |`TL_fix t]
      value t_ID = fun ~c -> c .`T_ID . con
      value t_COMP = fun ~t1 ~t2 -> {t1; t2} .`T_COMP . con
      value t_PR = fun ~lc ~i -> {lc; i} .`T_PR . con
      value t_RECORD = fun ~c ~lt -> {c; lt} .`T_RECORD . con
      value t_pp = fun ~c ~lt -> {c; lt} .`T_pp . con
      value t_ss = fun ~c ~lt -> {c; lt} .`T_ss . con
      value t_ee = fun ~lt ~i ~t -> {lt; i; t} .`T_ee . con
      value t_ii = fun ~t -> t .`T_ii . con
      value t_tt = fun ~t -> t .`T_tt . con
      value t_id = fun ~f -> f .`T_id . con
      value t_comp = fun ~t1 ~t2 -> {t1; t2} .`T_comp . con
      value t_pr = fun ~lf ~i -> {lf; i} .`T_pr . con
      value t_record = fun ~f ~lt -> {f; lt} .`T_record . con
      value t_in = fun ~lf ~i -> {lf; i} .`T_in . con
      value t_case = fun ~lt ~h -> {lt; h} .`T_case . con
      value tl_case = fun ~f ~lt ~h -> {f; lt; h} .`TL_case . con
      value t_appl = fun ~lf ~i ~f -> {lf; i; f} .`T_appl . con
      value t_curry = fun ~i ~t -> {i; t} .`T_curry . con
      value tl_map = fun ~f ~t -> {f; t} .`TL_map . con
      value t_con = fun ~f -> f .`T_con . con
      value t_fold = fun ~f ~t -> {f; t} .`T_fold . con
      value tl_fold = fun ~f ~t -> {f; t} .`TL_fold . con
      value tl_de = fun ~f -> f .`TL_de . con
      value t_de = fun ~f -> f .`T_de . con
      value t_unfold = fun ~f ~t -> {f; t} .`T_unfold . con
      value tl_unfold = fun ~f ~t -> {f; t} .`TL_unfold . con
      value tl_con = fun ~f -> f .`TL_con . con
      value t_fix = fun ~t -> t .`T_fix . con
      value tl_fix = fun ~t -> t .`TL_fix . con
    end
  spec EqCat =
  ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  EqCat =
    struct
      value eq_cat = fun ~c1 ~c2 -> `True
    end
  spec ToolCat =
  ~Cat ->
    sig
      value find : ~i:Index.t ~l:CatIList.t -> Cat.t
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolCat =
    :: ~EqCat -> ToolCat
    struct
      value find = fun ~i ~l ->
        match CatIList.find_ok ~i ~l with
        [`OK c -> c
	|`Error er -> Cat.c_BB]
      value append_ok = fun ~l1 ~l2 -> `Error
      value diff = fun ~l1 ~l2 -> l1
      value inter = fun ~l1 ~l2 -> l1
    end
  spec EqFunct =
  ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  EqFunct =
    struct
      value eq_funct = fun ~f1 ~f2 -> `True
    end
  spec ToolFunct =
  ~Funct ->
    sig
      value find : ~i:Index.t ~l:FunctIList.t -> Funct.t
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolFunct =
    :: ~EqFunct -> ToolFunct
    struct
      value find = fun ~i ~l ->
        match FunctIList.find_ok ~i ~l with
        [`OK f -> f
	|`Error er -> Funct.f_ID ~c:Cat.c_BB]
      value append_ok = fun ~l1 ~l2 -> `Error
      value seteq = fun ~l1 ~l2 -> `True
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
      value src : ~f:Funct.t -> Cat.t
      value trg : ~f:Funct.t -> Cat.t
      value trg' : ~f:Funct.t -> Cat.t
    end
  module SrcDule =
    :: ~ToolCat -> SrcDule
    struct
      value unPP = fun ~c ->
	match Cat.de_cat ~c with
	[`C_PP lc -> lc
	|`C_BB -> CatIList.nil]
      value unPPok = fun ~c ->
	match Cat.de_cat ~c with
	[`C_PP lc -> lc .`OK
	|`C_BB -> `Error ]
      value src =
        let fiur = fun ~f ->
          match Cat.de_cat ~c:f with
          [`C_PP l -> ToolCat.find ~i:Index.atj ~l
          |`C_BB -> Cat.c_BB]
	in
	fun ~f ->
	  match Funct.ind_funct ~f with
	  fold [`F_ID c -> c
 	        |`F_COMP f1xf2 -> f1xf2.f1
		|`F_PR lcxi -> (Cat.c_PP ~lc:lcxi.lc)
		|`F_RECORD cxlf -> cxlf.c
		|`F_pp cxlf -> cxlf.c
		|`F_ss cxlf -> cxlf.c
		|`F_ee lfxixf -> lfxixf.f
		|`F_ii fun ~it -> fiur ~f:it
		|`F_tt f -> fiur ~f]
      value rec trg = fun ~f ->
	match Funct.de_funct ~f with
	[`F_ID c -> c
 	|`F_COMP f1xf2 -> trg ~f:f1xf2.f2
	|`F_PR lcxi -> ToolCat.find ~i:lcxi.i ~l:lcxi.lc
	|`F_RECORD cxlf -> cxlf.c
	|`F_pp -> Cat.c_BB
	|`F_ss -> Cat.c_BB
	|`F_ee -> Cat.c_BB
	|`F_ii f -> trg ~f
	|`F_tt f -> trg ~f]
      value trg' = fun ~f ->
	match Funct.ind_funct ~f with
	fold [`F_ID c -> c
 	      |`F_COMP f1xf2 -> f1xf2.f2
	      |`F_PR lcxi -> ToolCat.find ~i:lcxi.i ~l:lcxi.lc
	      |`F_RECORD cxlf -> cxlf.c
	      |`F_pp -> Cat.c_BB
	      |`F_ss -> Cat.c_BB
	      |`F_ee -> Cat.c_BB
	      |`F_ii f -> f
	      |`F_tt f -> f]
    end
  spec DomDule =
  ~Trans -> 
    sig
      value unpp : ~f:Funct.t -> FunctIList.t
      value unpp_ok : ~f:Funct.t -> [`OK FunctIList.t|`Error]
      value dom : ~t:Trans.t -> Funct.t
      value cod : ~t:Trans.t -> Funct.t
    end
  DomDule =
    struct
      value unpp = fun ~f ->
	match Funct.de_funct ~f with
	[`F_pp cxlf -> cxlf.lf
	|`F_ID c -> FunctIList.nil
 	|`F_COMP f1xf2 -> FunctIList.nil
	|`F_PR lcxi -> FunctIList.nil
	|`F_RECORD cxlf -> FunctIList.nil
	|`F_ss cxlf -> FunctIList.nil
	|`F_ee lfxixf -> FunctIList.nil
	|`F_ii f -> FunctIList.nil
	|`F_tt f -> FunctIList.nil]
      value unpp_ok = fun ~f ->
	match Funct.de_funct ~f with
	[`F_pp cxlf -> cxlf.lf .`OK
	|`F_ID c -> `Error
 	|`F_COMP f1xf2 -> `Error
	|`F_PR lcxi -> `Error
	|`F_RECORD cxlf -> `Error
	|`F_ss cxlf -> `Error
	|`F_ee lfxixf -> `Error
	|`F_ii f -> `Error
	|`F_tt f -> `Error]
      value dom = fun ~t -> Funct.f_ID ~c:Cat.c_BB
      value cod = fun ~t -> Funct.f_ID ~c:Cat.c_BB
    end

  spec ToolSCat =
  ~Cat ->
    sig
      value find : ~i:Index.t ~l:CatIList.t -> Cat.t
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolSCat =
    :: ~ToolCat -> ToolSCat
    struct
      value find = ToolCat.find
      value append_ok = ToolCat.append_ok
      value diff = ToolCat.diff
      value inter = ToolCat.inter
    end
  spec ToolSFunct =
  ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value find : ~i:Index.t ~l:FunctIList.t -> Funct.t
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolSFunct =
  :: ~ToolFunct -> ToolSFunct
    struct
      value bfold1ok = fun ~init ~f ~l
          -> `Error
      value imap_cf = fun ~f ~l ->
	FunctIList.nil
      value imap_fc = fun ~f ~l ->
	CatIList.nil
      value bmap1ok_cf = fun
	~f ~l ->
          `Error
      value ifold1ok_fc = fun
        ~init
        ~f
        ~l
          -> `Error
      value find = ToolFunct.find
      value append_ok = ToolFunct.append_ok
      value seteq = ToolFunct.seteq
    end
  spec ToolSTrans =
  ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  ToolSTrans = 
    struct
      value vmap_tf = fun ~f ~l ->
	FunctIList.nil
      value bmap1ok_ft = fun ~f ~l -> `Error
    end

  library SLink =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value append : ~l1:t ~l2:t -> t
      value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
      value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
      value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
      value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
    end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value c_PP : ~lc:CatIList.t -> t
      value c_BB : t
    end
  spec EqCat = 
  ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat =
  ~Cat ->
    sig
      value find : ~i:Index.t ~l:CatIList.t -> Cat.t
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
      value f_ID : ~c:Cat.t -> t
      value f_COMP : ~f1:t ~f2:t -> t
      value f_PR : ~lc:CatIList.t ~i:Index.t -> t
      value f_RECORD : ~c:Cat.t ~lf:FunctIList.t -> t
      value f_pp : ~c:Cat.t ~lf:FunctIList.t -> t
    end
  spec EqFunct =
  ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct =
  ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value find : ~i:Index.t ~l:FunctIList.t -> Funct.t
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
      value t_ID : ~c:Cat.t -> t
      value t_COMP : ~t1:t ~t2:t -> t
      value t_PR : ~lc:CatIList.t ~i:Index.t -> t
      value t_RECORD : ~c:Cat.t ~lt:TransIList.t -> t
      value t_pp : ~c:Cat.t ~lt:TransIList.t -> t
      value t_id : ~f:Funct.t -> t
      value t_comp : ~t1:t ~t2:t -> t
      value t_pr : ~lf:FunctIList.t ~i:Index.t -> t
      value t_record : ~f:Funct.t ~lt:TransIList.t -> t
    end
  spec ToolSTrans =
  ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
      value src : ~f:Funct.t -> Cat.t
      value trg : ~f:Funct.t -> Cat.t
      value trg' : ~f:Funct.t -> Cat.t
    end
  spec DomDule =
  ~Trans -> 
    sig
      value unpp : ~f:Funct.t -> FunctIList.t
      value unpp_ok : ~f:Funct.t -> [`OK FunctIList.t|`Error]
      value dom : ~t:Trans.t -> Funct.t
      value cod : ~t:Trans.t -> Funct.t
    end
  spec ToolSSign = 
  ~Trans ->
    sig
      value singlePp : ~ls:FunctIList.t ~i:Index.t -> 
        {c : Cat.t; 
	 lb : CatIList.t; 
	 ld : CatIList.t}
      value footPp : ~c:Cat.t ~i:Index.t ~s:Funct.t -> Funct.t
      value att_dule : ~m:Trans.t -> Funct.t
    end
  ToolSSign =
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~DomDule -> ToolSSign
    struct
      value singlePp = fun ~ls ~i -> 
	let s = ToolSFunct.find ~i ~l:ls in
        let c = SrcDule.src ~f:s in
	let lc = SrcDule.unPP ~c in
	let lcdu = CatIList.ifilter ~p:Index.isDU ~l:lc in
	let lty = ToolSCat.diff ~l1:lc ~l2:lcdu 
	    lf = DomDule.unpp ~f:s in
        let lfdu = FunctIList.ifilter ~p:Index.isDU ~l:lf in
        let lcom = ToolSFunct.imap_fc ~f:(fun ~i -> 
          ToolSCat.find ~i ~l:lcdu) ~l:lfdu in
	let lb = CatIList.append ~l1:lcom ~l2:lty
	    ld = ToolSCat.diff ~l1:lcdu ~l2:lcom in
	{c; lb; ld}
      value footPp = fun ~c ~i ~s ->
	let lc = SrcDule.unPP ~c in
        let lb = SrcDule.unPP ~c:(ToolSCat.find ~i ~l:lc) in
	let f_PR_lc_i = Funct.f_PR ~lc ~i in
	let pib = ToolSFunct.imap_cf ~f:(fun ~i -> 
	  Funct.f_COMP ~f1:f_PR_lc_i ~f2:(Funct.f_PR ~lc:lb ~i)) ~l:lb in
	let le = SrcDule.unPP ~c:(SrcDule.src ~f:s) in
	let ld = ToolSCat.diff ~l1:le ~l2:lb in
	let f_PR_lc = fun ~i -> Funct.f_PR ~lc ~i in
	let pid = ToolSFunct.imap_cf ~f:f_PR_lc ~l:ld in
	Funct.f_RECORD ~c ~lf:(FunctIList.append ~l1:pib ~l2:pid)
      value att_dule = fun ~m ->
        let f = DomDule.dom ~t:m in
	let le = SrcDule.unPP ~c:(SrcDule.trg ~f) in
	Funct.f_COMP ~f1:f ~f2:(Funct.f_PR ~lc:le ~i:Index.att)
    end
  spec OkSSign = 
  ~Funct ->
    sig
      value legPp : ~c:Cat.t ~i:Index.t ~s:Funct.t -> Funct.t
      value lsrcPp : ~ls:FunctIList.t -> [`OK CatIList.t|`Error]
      value lsrcWw : ~f1:Funct.t ~s2:Funct.t ->
        [`OK {lc1 : CatIList.t; 
	      le1 : CatIList.t; 
	      le12 : CatIList.t; 
	      ld : CatIList.t; 
	      la : CatIList.t}
        |`Error]
    end
  OkSSign = 
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~ToolSSign -> OkSSign
    struct
      value legPp = fun ~c ~i ~s ->
        Funct.f_COMP ~f1:(ToolSSign.footPp ~c ~i ~s) ~f2:s
      value lsrcPp = fun ~ls ->
        let single_src = fun ~i ~r ->
	  match r with
	  [`OK r ->
	     let rl = ToolSSign.singlePp ~ls ~i in
	     let l1 = CatIList.cons ~i ~v:(Cat.c_PP ~lc:rl.lb) 
               ~l:CatIList.nil in
	     match ToolSCat.append_ok ~l1 ~l2:rl.ld with
	     [`OK la ->
		ToolSCat.append_ok ~l1:la ~l2:r
             |`Error er -> er .`Error]
          |`Error er -> er .`Error]
	in
	ToolSFunct.ifold1ok_fc ~init:CatIList.nil ~f:single_src ~l:ls
      value lsrcWw = fun ~f1 ~s2 ->
        let lc1 = SrcDule.unPP ~c:(SrcDule.src ~f:f1)
	    le1 = SrcDule.unPP ~c:(SrcDule.trg ~f:f1)
	    le2 = SrcDule.unPP ~c:(SrcDule.src ~f:s2) in
	let ld = ToolSCat.diff ~l1:le2 ~l2:le1 in
	let le12 = ToolSCat.diff ~l1:le2 ~l2:ld in
	match ToolSCat.append_ok ~l1:ld ~l2:lc1 with
        [`OK la ->
	   {lc1; le1; le12; ld; la} .`OK
        |`Error er -> er .`Error]
    end
  spec SemSSign =
  ~Trans ->
    sig
      value s_Pp : ~ls:FunctIList.t -> [`OK Funct.t|`Error] 
      value s_Bb : ~lc:CatIList.t ~lf:FunctIList.t -> Funct.t
      value s_Ww : ~m1:Trans.t ~s2:Funct.t -> [`OK Funct.t|`Error]
    end
  SemSSign = 
    :: ~ToolSFunct ~ToolSSign ~OkSSign -> SemSSign
    struct
      value s_Pp = fun ~ls ->
        match OkSSign.lsrcPp ~ls with
	[`OK lc -> 
	   let c = Cat.c_PP ~lc in
           let leg_lc = fun ~i ~v -> 
	     OkSSign.legPp ~c ~i ~s:v in
	   let legs = FunctIList.bmap ~f:leg_lc ~l:ls in
 	   let body = Funct.f_pp ~c:(Cat.c_PP ~lc) ~lf:legs in
 	   body .`OK
        |`Error er -> er .`Error]
      value s_Bb = fun ~lc ~lf -> Funct.f_pp ~c:(Cat.c_PP ~lc) ~lf
      value s_Ww = fun ~m1 ~s2 ->
        let f1 = ToolSSign.att_dule ~m:m1 in
        match OkSSign.lsrcWw ~f1 ~s2 with
        [`OK rl ->
 	   let la = rl.la in
	   let a = Cat.c_PP ~lc:la in
	   let f_PR_la = fun ~i -> Funct.f_PR ~lc:la ~i in
	   let pic1 = ToolSFunct.imap_cf ~f:f_PR_la ~l:rl.lc1 in 
	   let re1 = Funct.f_RECORD ~c:a ~lf:pic1 in
	   let f = Funct.f_COMP ~f1:re1 ~f2:f1 in
	   let f_COMP_f = fun ~i -> 
	     Funct.f_COMP ~f1:f ~f2:(Funct.f_PR ~lc:rl.le1 ~i) in
	   let pife1 = ToolSFunct.imap_cf ~f:f_COMP_f ~l:rl.le12 in
	   let pid = ToolSFunct.imap_cf ~f:f_PR_la ~l:rl.ld in 
	   let pipi = FunctIList.append ~l1:pife1 ~l2:pid in
	   let re = Funct.f_RECORD ~c:a ~lf:pipi in
	   (Funct.f_COMP ~f1:re ~f2:s2) .`OK
        |`Error er -> er .`Error]
    end
  spec ToolSDule = 
  ~Trans ->
    sig
      value pack : ~f:Funct.t ~t:Trans.t -> Trans.t
      value unpack : ~m:Trans.t -> {f:Funct.t; t:Trans.t}
    end
  ToolSDule = 
    :: ~SrcDule ~DomDule -> ToolSDule
    struct
      value pack = fun ~f ~t ->
	Trans.t_RECORD ~c:(SrcDule.src ~f) 
	  ~lt:(TransIList.cons ~i:Index.att ~v:(Trans.t_id ~f)
                ~l:(TransIList.cons ~i:Index.atv ~v:t ~l:TransIList.nil))
      value unpack = fun ~m ->
        let le = SrcDule.unPP ~c:(SrcDule.trg ~f:(DomDule.dom ~t:m)) in
	{f = DomDule.dom 
           ~t:(Trans.t_COMP ~t1:m ~t2:(Trans.t_PR ~lc:le ~i:Index.att));
	 t = Trans.t_COMP ~t1:m ~t2:(Trans.t_PR ~lc:le ~i:Index.atv)}
    end
  spec OkSDule = 
  ~Trans ->
    sig
      value mayRecord : ~lf:FunctIList.t ~ls:FunctIList.t -> 
        [`OK FunctIList.t|`Error]
      value mayBase : ~r:Funct.t ~s:Funct.t 
	              ~lg:FunctIList.t ~lh:FunctIList.t -> 
			[`OK FunctIList.t|`Error]
      value mayInst : ~f1:Funct.t ~f2:Funct.t -> [`OK Funct.t|`Error]
      value mayTrim_f : ~e:Cat.t ~c:Cat.t -> [`OK Funct.t|`Error]
      value mayTrim_t : ~h:Funct.t ~f:Funct.t -> [`OK Trans.t|`Error]
    end
  OkSDule = 
    :: ~EqCat ~ToolSCat ~EqFunct ~ToolSFunct ~ToolSTrans 
       ~SrcDule ~DomDule ~ToolSSign -> OkSDule
    struct
      value mayRecord = fun ~lf ~ls -> 
	let cut_at_i = 
         fun ~i ~v ~r ->
	  match r with
	  [`OK r ->
	     let rl = ToolSSign.singlePp ~ls ~i in
	     let lc = SrcDule.unPP ~c:rl.c in
	     let pib = ToolSFunct.imap_cf ~f:Funct.f_PR(~lc) ~l:rl.lb in
	     let fib = 
               Funct.f_COMP ~f1:v ~f2:(Funct.f_RECORD ~c:rl.c ~lf:pib)
	         lfid = ToolSFunct.imap_cf ~f:(fun ~i -> 
               Funct.f_COMP ~f1:v ~f2:(Funct.f_PR ~lc:lc ~i)) ~l:rl.ld in
	     let l1 = FunctIList.cons ~i ~v:fib ~l:FunctIList.nil in
	     match ToolSFunct.append_ok ~l1 ~l2:lfid with
	     [`OK lg ->
		ToolSFunct.append_ok ~l1:lg ~l2:r
             |`Error er -> er .`Error]
          |`Error er -> er .`Error]
	in
	ToolSFunct.bfold1ok ~init:FunctIList.nil ~f:cut_at_i ~l:lf
      value mayBase = fun ~r ~s ~lg ~lh -> 
	let c = SrcDule.src ~f:r
	    e = SrcDule.src ~f:s in
	let lc = SrcDule.unPP ~c
	    le = SrcDule.unPP ~c:e in
	let ld = ToolSCat.inter ~l1:lc ~l2:le in
  	let f_PR_lc = fun ~i -> Funct.f_PR ~lc ~i in
	let pild = ToolSFunct.imap_cf ~f:f_PR_lc ~l:ld in
	let lf = FunctIList.append ~l1:pild ~l2:lg in
	let f = Funct.f_RECORD ~c ~lf in
	match EqCat.eq_cat ~c1:(SrcDule.trg ~f) ~c2:e with
        [`True ->
	   let lh1 = DomDule.unpp ~f:(Funct.f_COMP ~f1:f ~f2:s) in
	   match ToolSFunct.seteq ~l1:lh1 ~l2:lh with
           [`True ->
  	      lf .`OK
	   |`False -> `Error]
	|`False -> `Error]
      value mayInst = fun ~f1 ~f2 ->
	let c1 = SrcDule.src ~f:f1 in
	let lc1 = SrcDule.unPP ~c:c1
	    le1 = SrcDule.unPP ~c:(SrcDule.trg ~f:f1)
	    le2 = SrcDule.unPP ~c:(SrcDule.trg ~f:f2) in
	let ld = ToolSCat.diff ~l1:le2 ~l2:le1
	    f12 = Funct.f_COMP ~f1 ~f2 in
	let pid = ToolSFunct.imap_cf ~f:(fun ~i -> 
          Funct.f_COMP ~f1:f12 ~f2:(Funct.f_PR ~lc:le2 ~i)) ~l:ld in 
  	let f_PR_lc1 = fun ~i -> Funct.f_PR ~lc:lc1 ~i in
	let pic1 = ToolSFunct.imap_cf ~f:f_PR_lc1 ~l:lc1 in 
	match ToolSFunct.append_ok ~l1:pid ~l2:pic1 with
	[`OK lf ->
	   (Funct.f_RECORD ~c:c1 ~lf) .`OK
        |`Error er -> er .`Error]
      value rec mayTrim_f = fun ~e ~c ->
	match SrcDule.unPPok ~c with
	[`OK lc ->
	   match SrcDule.unPPok ~c:e with
	   [`OK le ->
	      let fsu = fun ~i ~v ->
		match CatIList.find_ok ~i ~l:le with
		[`OK e ->
		   match mayTrim_f ~e ~c:v with
		   [`OK sf ->
		      (Funct.f_COMP ~f1:(Funct.f_PR ~lc:le ~i) ~f2:sf) .`OK
		   |`Error er -> er .`Error]
		|`Error er -> er .`Error]
	      in
	      match ToolSFunct.bmap1ok_cf ~f:fsu ~l:lc with
	      [`OK lf ->
		 (Funct.f_RECORD ~c:e ~lf) .`OK
	      |`Error er -> er .`Error]
           |`Error er -> er .`Error]
	|`Error er ->
           match EqCat.eq_cat ~c1:e ~c2:c with
	   [`True ->
	      (Funct.f_ID ~c) .`OK
	   |`False -> `Error]]
      value rec mayTrim_t = fun ~h ~f ->
	match DomDule.unpp_ok ~f with
	[`OK lf ->
	   match DomDule.unpp_ok ~f:h with
	   [`OK lh ->
	      let fsu = fun ~i ~v ->
		match FunctIList.find_ok ~i ~l:lh with
		[`OK h ->
  		   match mayTrim_t ~h ~f:v with
		   [`OK sf ->
		      (Trans.t_comp ~t1:(Trans.t_pr ~lf:lh ~i) ~t2:sf) .`OK
		   |`Error er -> er .`Error]
		|`Error er -> er .`Error]
	      in
	      match ToolSTrans.bmap1ok_ft ~f:fsu ~l:lf with
	      [`OK lt ->
		 (Trans.t_record ~f:h ~lt) .`OK
	      |`Error er -> er .`Error]
           |`Error er -> er .`Error]
	|`Error er ->
           match EqFunct.eq_funct ~f1:h ~f2:f with
	   [`True ->
	      (Trans.t_id ~f) .`OK
	   |`False -> `Error]]
    end
  spec SemSDule =
  ~Trans ->
    sig
      value m_Id : ~s:Funct.t -> Trans.t
      value m_Comp : ~m1:Trans.t ~m2:Trans.t -> Trans.t
      value m_Pr : ~lr:FunctIList.t ~i:Index.t ~s:Funct.t -> 
	[`OK Trans.t|`Error]
      value m_Record : ~r:Funct.t ~lm:TransIList.t ~ls:FunctIList.t ->
        [`OK Trans.t|`Error]
      value m_Base : ~r:Funct.t ~s:Funct.t 
	             ~lg:FunctIList.t ~lt:TransIList.t ~lh:FunctIList.t ->
                       [`OK Trans.t|`Error]
      value m_Inst : ~m1:Trans.t ~m2:Trans.t -> [`OK Trans.t|`Error]
      value m_Trim : ~m1:Trans.t ~r2:Funct.t -> [`OK Trans.t|`Error]
    end
  SemSDule = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~ToolSSign ~OkSSign ~ToolSDule ~OkSDule ->
         SemSDule
    struct
      value m_Id = fun ~s ->
        let c = SrcDule.src ~f:s in
        ToolSDule.pack ~f:(Funct.f_ID ~c) ~t:(Trans.t_id ~f:s)
      value m_Comp = fun ~m1 ~m2 ->
	let f1xt1 = ToolSDule.unpack ~m:m1
	    f2xt2 = ToolSDule.unpack ~m:m2 in
	let f = Funct.f_COMP ~f1:f1xt1.f ~f2:f2xt2.f in
	let it2 = Trans.t_COMP ~t1:(Trans.t_id ~f:f1xt1.f) ~t2:f2xt2.t in
	let t = Trans.t_comp ~t1:f1xt1.t ~t2:it2 in
	ToolSDule.pack ~f ~t
      value m_Pr = fun ~lr ~i ~s ->
        match OkSSign.lsrcPp ~ls:lr with
	[`OK lc -> 
	   let c = Cat.c_PP ~lc in
	   let foot_i = ToolSSign.footPp ~c ~i ~s in
           let leg_lc = fun ~i ~v -> 
	     OkSSign.legPp ~c ~i ~s:v in
	   let legs = FunctIList.bmap ~f:leg_lc ~l:lr in
	   let t = Trans.t_pr ~lf:legs ~i in
 	   ToolSDule.pack ~f:foot_i ~t .`OK
        |`Error er -> er .`Error]
      value m_Record = fun ~r ~lm ~ls ->
        let unf = fun ~v -> (ToolSDule.unpack ~m:v).f in
        let lf = ToolSTrans.vmap_tf ~f:unf ~l:lm in
        let unt = fun ~v -> (ToolSDule.unpack ~m:v).t in
        let lt = TransIList.vmap ~f:unt ~l:lm in
        match OkSDule.mayRecord ~lf ~ls with
	[`OK lf -> 
	   let c = SrcDule.src ~f:r in
	   let f = Funct.f_RECORD ~c ~lf
	       t = Trans.t_record ~f:r ~lt in
	   ToolSDule.pack ~f ~t .`OK
        |`Error er -> er .`Error]
      value m_Base = fun ~r ~s ~lg ~lt ~lh ->
        match OkSDule.mayBase ~r ~s ~lg ~lh with
	[`OK lf -> 
	   let c = SrcDule.src ~f:r in
	   let f = Funct.f_RECORD ~c ~lf
	       t = Trans.t_record ~f:r ~lt in
	   ToolSDule.pack ~f ~t .`OK
        |`Error er -> er .`Error]
      value m_Inst = fun ~m1 ~m2 ->
	let f1xt1 = ToolSDule.unpack ~m:m1
	    f2xt2 = ToolSDule.unpack ~m:m2 in
        match OkSDule.mayInst ~f1:f1xt1.f ~f2:f2xt2.f with
	[`OK f -> 
  	   let it2 = Trans.t_COMP ~t1:(Trans.t_id ~f:f1xt1.f) ~t2:f2xt2.t in
	   let t = Trans.t_comp ~t1:f1xt1.t ~t2:it2 in
	   ToolSDule.pack ~f ~t .`OK
        |`Error er -> er .`Error]
      value m_Trim = fun ~m1 ~r2 ->
	let f1xt1 = ToolSDule.unpack ~m:m1 in
        let e1 = SrcDule.trg ~f:f1xt1.f
            c2 = SrcDule.src ~f:r2 in
        match OkSDule.mayTrim_f ~e:e1 ~c:c2 with
	[`OK scf -> 
	   let f = Funct.f_COMP ~f1:f1xt1.f ~f2:scf in
	   let fcr2 = Funct.f_COMP ~f1:f ~f2:r2
	       f1s1 = DomDule.cod ~t:f1xt1.t in
           match OkSDule.mayTrim_t ~h:f1s1 ~f:fcr2 with
	   [`OK sct -> 
	      let t = Trans.t_comp ~t1:f1xt1.t ~t2:sct in
  	      ToolSDule.pack ~f ~t .`OK
           |`Error er -> er .`Error]
        |`Error er -> er .`Error]
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  SemSLink = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~SemSSign ~ToolSDule ~SemSDule -> SemSLink
    struct
      value m_Accord = fun ~lr ~lm ~ls ->
	`Error
      value m_Concord = fun ~lr ~lm ~ls ->
	`Error
      value m_Link = fun ~lr ~lm ~ls ->
	`Error
    end
end
  SLink_on_LDule = load SLink with
    {{EqCat; 
      ToolSCat;
      EqFunct; 
      ToolSFunct;
      ToolSTrans;
      SrcDule; 
      DomDule}}

  library SInd =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value append : ~l1:t ~l2:t -> t
      value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
      value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
      value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
      value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value c_PP : ~lc:CatIList.t -> t
      value c_BB : t
    end
  spec EqCat = 
  ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat =
  ~Cat ->
    sig
      value find : ~i:Index.t ~l:CatIList.t -> Cat.t
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
      value f_ID : ~c:Cat.t -> t
      value f_COMP : ~f1:t ~f2:t -> t
      value f_PR : ~lc:CatIList.t ~i:Index.t -> t
      value f_RECORD : ~c:Cat.t ~lf:FunctIList.t -> t
      value f_pp : ~c:Cat.t ~lf:FunctIList.t -> t
      value f_ii : ~f:t -> t
    end
  spec EqFunct =
  ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct =
  ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value find : ~i:Index.t ~l:FunctIList.t -> Funct.t
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
      value t_ID : ~c:Cat.t -> t
      value t_COMP : ~t1:t ~t2:t -> t
      value t_PR : ~lc:CatIList.t ~i:Index.t -> t
      value t_RECORD : ~c:Cat.t ~lt:TransIList.t -> t
      value t_pp : ~c:Cat.t ~lt:TransIList.t -> t
      value t_ii : ~t:t -> t
      value t_id : ~f:Funct.t -> t
      value t_comp : ~t1:t ~t2:t -> t
      value t_pr : ~lf:FunctIList.t ~i:Index.t -> t
      value t_record : ~f:Funct.t ~lt:TransIList.t -> t
      value t_con : ~f:Funct.t -> t
      value tl_de : ~f:Funct.t -> t
    end
  spec ToolSTrans =
  ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
      value src : ~f:Funct.t -> Cat.t
      value trg : ~f:Funct.t -> Cat.t
      value trg' : ~f:Funct.t -> Cat.t
    end
  spec DomDule =
  ~Trans -> 
    sig
      value unpp : ~f:Funct.t -> FunctIList.t
      value unpp_ok : ~f:Funct.t -> [`OK FunctIList.t|`Error]
      value dom : ~t:Trans.t -> Funct.t
      value cod : ~t:Trans.t -> Funct.t
    end
  spec SemSSign =
  ~Trans ->
    sig
      value s_Pp : ~ls:FunctIList.t -> [`OK Funct.t|`Error] 
      value s_Bb : ~lc:CatIList.t ~lf:FunctIList.t -> Funct.t
      value s_Ww : ~m1:Trans.t ~s2:Funct.t -> [`OK Funct.t|`Error]
    end
  spec ToolSDule = 
  ~Trans ->
    sig
      value pack : ~f:Funct.t ~t:Trans.t -> Trans.t
      value unpack : ~m:Trans.t -> {f:Funct.t; t:Trans.t}
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  spec ToolSInd = 
  ~Trans ->
    sig
      value addcon : ~f:Funct.t ~g:Funct.t -> Trans.t
    end
  ToolSInd =
    :: ~ToolSTrans ~SrcDule ~DomDule -> ToolSInd
    struct
      value addcon = fun ~f ~g -> Trans.t_ID ~c:Cat.c_BB
    end 
  spec SemSInd =
  ~Trans ->
    sig
      value m_Ind : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  SemSInd =
    :: ~SrcDule ~DomDule ~SemSSign ~ToolSDule ~SemSLink ~ToolSInd -> SemSInd
    struct
      value m_Ind = fun ~lr ~lm ~ls ->
	`Error
    end
end
  SemSSign = SLink_on_LDule | SemSSign
  ToolSDule = SLink_on_LDule | ToolSDule 
  SemSLink = SLink_on_LDule | SemSLink
  SInd_on_LDule = load SInd with 
    {{SemSSign; ToolSDule; SemSLink; DomDule; SrcDule; ToolSTrans}}

  library ElabSDule =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value append : ~l1:t ~l2:t -> t
      value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
      value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
      value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
      value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
   end
  library IList = load IList :> IList
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value c_PP : ~lc:CatIList.t -> t
      value c_BB : t
    end
  spec EqCat = 
  ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat =
  ~Cat ->
    sig
      value find : ~i:Index.t ~l:CatIList.t -> Cat.t
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec EqFunct =
  ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct =
  ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value find : ~i:Index.t ~l:FunctIList.t -> Funct.t
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec ToolSTrans =
  ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
      value src : ~f:Funct.t -> Cat.t
      value trg : ~f:Funct.t -> Cat.t
      value trg' : ~f:Funct.t -> Cat.t
    end
  spec SemSSign =
  ~Trans ->
    sig
      value s_Pp : ~ls:FunctIList.t -> [`OK Funct.t|`Error] 
      value s_Bb : ~lc:CatIList.t ~lf:FunctIList.t -> Funct.t
      value s_Ww : ~m1:Trans.t ~s2:Funct.t -> [`OK Funct.t|`Error]
    end
  spec SemSDule =
  ~Trans ->
    sig
      value m_Id : ~s:Funct.t -> Trans.t
      value m_Comp : ~m1:Trans.t ~m2:Trans.t -> Trans.t
      value m_Pr : ~lr:FunctIList.t ~i:Index.t ~s:Funct.t -> 
	[`OK Trans.t|`Error]
      value m_Record : ~r:Funct.t ~lm:TransIList.t ~ls:FunctIList.t ->
        [`OK Trans.t|`Error]
      value m_Base : ~r:Funct.t ~s:Funct.t 
	             ~lg:FunctIList.t ~lt:TransIList.t ~lh:FunctIList.t ->
                       [`OK Trans.t|`Error]
      value m_Inst : ~m1:Trans.t ~m2:Trans.t -> [`OK Trans.t|`Error]
      value m_Trim : ~m1:Trans.t ~r2:Funct.t -> [`OK Trans.t|`Error]
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  spec SemSInd =
  ~Trans ->
    sig
      value m_Ind : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  spec rec SSignIList = IList with {{Value = SSign}}
  and SSign =
  ~FunctIList ->
    sig
      type t
      value s_Pp : ~ls:SSignIList.t -> t
      value s_Bb : ~lc:CatIList.t ~lf:FunctIList.t -> t
      value s_Ww : ~m1:SDule.t ~s2:t -> t
      value el_sign : ~s:t -> [`OK Funct.t|`Error]
    end
  and SDuleIList = IList with {{Value = SDule}}
  and SDule =
  ~TransIList ->
    sig
      type t
      value m_Id : ~s:SSign.t -> t
      value m_Comp : ~m1:t ~m2:t -> t
      value m_Pr : ~lr:SSignIList.t ~i:Index.t -> t
      value m_Record : ~r:SSign.t ~lm:SDuleIList.t -> t
      value m_Base : ~r:SSign.t ~s:SSign.t 
	             ~lg:FunctIList.t ~lt:TransIList.t -> t
      value m_Inst : ~m1:t ~m2:t -> t
      value m_Trim : ~m1:t ~r2:SSign.t -> t
      value m_Accord : ~lr:SSignIList.t ~lm:SDuleIList.t -> t
      value m_Concord : ~lr:SSignIList.t ~lm:SDuleIList.t -> t
      value m_Link : ~lr:SSignIList.t ~lm:SDuleIList.t -> t
      value m_Ind : ~lr:SSignIList.t ~lm:SDuleIList.t -> t
      value el_dule : ~m:t -> [`OK {r : Funct.t; 
				    s : Funct.t; 
				    m : Trans.t}
                              |`Error]
    end
  module ind SSignIList = load IList with {{Value = SSign}}
  and SSign = 
    struct
      type t = 
	ind t: [`S_Pp SSignIList.t
	       |`S_Bb {lc : CatIList.t; lf : FunctIList.t}
	       |`S_Ww {m1 : SDule.t; s2 : t}]
      value s_Pp = fun ~ls -> ls . `S_Pp . con
      value s_Bb = fun ~lc ~lf -> {lc; lf} . `S_Bb . con
      value s_Ww = fun ~m1 ~s2 -> {m1; s2} . `S_Ww . con
      value el_sign = fun ~s -> `Error
    end
  and SDuleIList = load IList with {{Value = SDule}}
  and SDule = 
    struct
      type t = 
        ind t: [`M_Id SSign.t
	       |`M_Comp {m1 : t; m2 : t}
	       |`M_Pr {lr : SSignIList.t; i : Index.t}
	       |`M_Record {r : SSign.t; lm : SDuleIList.t}
	       |`M_Base {r : SSign.t; s : SSign.t; 
			 lg : FunctIList.t; lt : TransIList.t}
	       |`M_Inst {m1 : t; m2 : t}
	       |`M_Trim {m1 : t; r2 : SSign.t}
	       |`M_Accord {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Concord {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Link {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Ind {lr : SSignIList.t; lm : SDuleIList.t}]
      value m_Id = fun ~s -> s .`M_Id . con
      value m_Comp = fun ~m1 ~m2 -> {m1; m2} .`M_Comp . con
      value m_Pr = fun ~lr ~i -> {lr; i} .`M_Pr . con
      value m_Record = fun ~r ~lm -> {r; lm} . `M_Record . con
      value m_Base = fun ~r ~s ~lg ~lt -> {r; s; lg; lt} .`M_Base . con
      value m_Inst = fun ~m1 ~m2 -> {m1; m2} .`M_Inst . con
      value m_Trim = fun ~m1 ~r2 -> {m1; r2} .`M_Trim . con
      value m_Accord = fun ~lr ~lm -> {lr; lm} .`M_Accord . con
      value m_Concord = fun ~lr ~lm -> {lr; lm} .`M_Concord . con
      value m_Link = fun ~lr ~lm -> {lr; lm} .`M_Link . con
      value m_Ind = fun ~lr ~lm -> {lr; lm} .`M_Ind . con
      value el_dule = fun ~m -> `Error
    end
  Test =
    :: ~SDule ~SSign ~SSignIList ~SrcDule -> 
      sig value test : [`OK Funct.t|`Error] end
    struct
      value test =
        let m = SDule.m_Id 
	  ~s:(SSign.s_Pp 
                ~ls:SSignIList.nil) in
        let rxsxm = SDule.el_dule ~m in
	match rxsxm with
	[`OK rxsxm -> rxsxm.r .`OK
	|`Error er -> `Error]
    end
end
  SemSDule = SLink_on_LDule | SemSDule 
  SemSInd = SInd_on_LDule | SemSInd  
  ElabSDule_on_LDule = load ElabSDule with 
    {{SemSSign; SemSDule; SemSLink; SemSInd; SrcDule; Trans}}
  Test = (ElabSDule_on_LDule | Test) :> 
    ~Funct -> sig value test : [`OK Funct.t|`Error] end
  Result =
    :: ~SrcDule ~Test : ~Funct -> sig value test : [`OK Funct.t|`Error] end -> 
      sig value ok : [`True|`False] end
    struct
      value ok =
let b = 
	match Test.test with
	[`OK r -> 
          match Cat.de_cat ~c:(SrcDule.src ~f:r) with
          [`C_PP lc -> `False
	  |`C_BB -> `False]
	|`Error er -> `True]
in assert b in
b
    end
end
 Result = Compiler . Result
end

Lo_prog8 =  
link spec 
  T = sig type t end
spec  Char = 
      sig 
        type t
        value chr : ~it:[`a {}|`b {}|`c {}
                         |`A {}|`B {}|`C {}] -> t
        value ord : ~it:t -> [`a {}|`b {}|`c {}
                              |`A {}|`B {}|`C {}]
        value upper : ~it:t -> t
        value lower : ~it:t -> t
      end
spec  List = 
    ~Elem:T ->
      sig
	type t
	value nil : t
	value cons : ~head:Elem.t ~tail:t -> t
	value list : ~it:t ->
          ind t': [`Nil {}| `Cons {head: Elem.t; tail: t'}]
      end
spec  EndoList =
    ~List ->
      sig
        value foldr : ~init:List.t 
                      ~f: ~e:Elem.t ~r:List.t -> List.t 
                      ~l:List.t -> List.t
	value mapt : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      end
spec  CharList =
    ~Char:Char ->
      {{Char; EndoList}}
spec  String =
    ~CharList ->
      sig
        value up : CharList.List.t
	value it : CharList.List.t
        value prefix : ~p:Char.t ~s:CharList.List.t -> CharList.List.t
	value shout : ~l:CharList.List.t -> CharList.List.t
      end
  spec Result = T
  Result = :: T struct type t = {} end
  Char =
    :: Char
struct
      type t = [`a {}|`b {}|`c {}
               |`A {}|`B {}|`C {}]
      value chr = fun ~it -> it
      value ord = fun ~it -> it
      value upper = [`a -> {} . `A|`b -> {} . `B|`c -> {} . `C
                    |`A -> {} . `A|`B -> {} . `B|`C -> {} . `C]
      value lower = [`a -> {} . `a|`b -> {} . `b|`c -> {} . `c
                    |`A -> {} . `a|`B -> {} . `b|`C -> {} . `c]
    end
  spec Elem = ~Char : Char -> T
  Elem =
struct
      type t = Char.t
    end
  List =
struct
      type t = ind t: [`Nil {}| `Cons {head: Elem.t; tail: t}]
      value nil = {} . `Nil . con
      value cons = fun ~head ~tail -> {head; tail} . `Cons . con
      value list = fun ~it -> it
    end
  EndoList =
struct
      value foldr = 
        fun ~(init:List.t) ~(f: ~e:Elem.t ~r:List.t -> List.t) 
	    ~(l:List.t) -> 
          match (match l with List.list) with
            fold [`Nil -> init
                  |`Cons ht -> f ~e:ht.head ~r:ht.tail]
      value mapt = 
        fun ~f ~l -> 
          match (match l with List.list) with
            fold [`Nil -> List.nil
                  |`Cons ht -> 
                     List.cons ~head:(f ~e:ht.head) ~tail:ht.tail]
  end
  CharList = : {{Char; EndoList}}
end

Lo_prog9 =  
link
  spec Char =
    sig 
      type t
      value c_quote : t
    end
  Char =
    struct
      type t = [`quote]
      value c_quote = `quote
    end
  spec Elem = sig type t end
  spec List = 
  ~Elem ->
    sig
    end
  library List =
    struct
    end
  spec CharList = List with {Elem = Char}
  module CharList = load List with {Elem = Char}
end

Lo_prog10 =  
link spec 
  T = sig type t end
spec 
  Value = sig type t end
spec 
  Elem = sig type t end
spec  List = 
    ~Elem : T ->
      sig
	type t
	value nil : t
	value cons : ~head:Elem.t ~tail:t -> t
	value list : ~it:t ->
          ind t': [`Nil {}| `Cons {head: Elem.t; tail: t'}]
      end
spec  Index
    = sig
        type t
	value eq : ~i:t ~j:t -> [`True|`False]
      end
spec  IElem = 
    ~Index 
    ~Value : T -> 
       sig
         type t
         value i : ~it:t -> Index.t
         value v : ~it:t -> Value.t
         value assoc : ~i:Index.t ~v:Value.t -> t
       end
 spec IElemList =
      {{List}}
spec  IList =
    ~Index 
    ~Value : T ->
      sig
        type t
      end
  library List =
    :: List
struct
      type t = ind t: [`Nil {}| `Cons {head: Elem.t; tail: t}]
      value nil = {} . `Nil . con
      value cons = fun ~head ~tail -> {head; tail} . `Cons . con
      value list = fun ~it -> it
    end
  library IElem =
    :: IElem
struct
      type t = {i: Index.t; v: Value.t}
      value i = fun ~it -> it.i
      value v = fun ~it -> it.v
      value assoc = fun ~i ~v -> {i; v}
    end
  library IList =
    :: ~IElemList -> IList
struct
      type t = IElemList.List.t
    end
  Index =
    :: Index
struct
      type t = {}
      value eq = fun ~i ~j -> {} . `True
    end
      Value = 
        :: T
struct
          type t = {}
        end
      IElem = load IElem
          Elem =
            :: ~IElem -> T
struct
              type t = IElem.t
            end
          List = load List
          IElemList = : {{List}}
      IList = load IList
end

Lo_prog42 =  
link
spec 
  Value = sig type t end
spec 
  Elem = sig type t end
  spec T = sig type t end
  spec Char =
    sig 
      type t
      value char : ~it:t -> [`a|`b|`c
                             |`A|`B|`C
                             |`quote]
      value c_a : t
      value c_b : t
      value c_c : t
      value c_A : t
      value c_B : t
      value c_C : t
      value c_quote : t
      value upper : ~it:t -> t
      value lower : ~it:t -> t
      value eq : ~it:t ~c:t -> [`True|`False]
    end
  Char =
    :: Char
 struct
     type t = [`a|`b|`c
               |`A|`B|`C
               |`quote]
      value char = fun ~it -> it
      value c_a = {} .`a
      value c_b = {} .`b
      value c_c = {} .`c
      value c_A = {} .`A
      value c_B = {} .`B
      value c_C = {} .`C
      value c_quote = {} .`quote
      value upper = [`a -> {} .`A|`b -> {} .`B|`c -> {} .`C
                    |`A -> {} .`A|`B -> {} .`B|`C -> {} .`C
		    |`quote -> {} . `quote]
      value lower = [`a -> {} .`a|`b -> {} .`b|`c -> {} .`c
                    |`A -> {} .`a|`B -> {} .`b|`C -> {} .`c
		    |`quote -> {} . `quote]
      value eq = fun ~it ~c -> {} . `True
    end
  spec List = 
  ~Elem:T ->
    sig
      type t
      value list : ~it:t ->
        ind t: [`Nil|`Cons {head: Elem.t; tail: t}]
      value nil : t
      value cons : ~head:Elem.t ~tail:t -> t
    end
  library List =
    :: List
struct
      type t = ind t: [`Nil|`Cons {head: Elem.t; tail: t}]
      value list = fun ~it -> it
      value nil = {} .`Nil . con
      value cons = fun ~head ~tail -> {head; tail} . `Cons . con
    end
  spec EndoList = 
  ~List ->
    sig
      value foldr : ~init:List.t 
                    ~f: ~e:Elem.t ~r:List.t -> List.t 
                    ~l:List.t -> List.t
      value mapt : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value append : ~it:List.t ~l:List.t -> List.t 
    end
  library EndoList =
    :: EndoList
struct
      value foldr = 
        fun ~init ~f ~l -> 
          match List.list ~it:l with
            fold [`Nil -> init
                  |`Cons ht -> f ~e:ht.head ~r:ht.tail]
      value mapt = 
        fun ~f ~l -> 
            (fold [`Nil fun ~f ~it -> List.nil
                  |`Cons fun ~f ~it:ht -> 
                     List.cons ~head:(f ~e:ht.head) ~tail:ht.tail])
	      ~f ~it:match l with List.list
      value append = 
        fun ~it ~l -> 
          match List.list ~it with
            fold [`Nil -> l
                  |`Cons ht -> List.cons ~head:ht.head ~tail:ht.tail]
    end
  spec CharList = List with {Elem = Char}
  CharList = load List with {Elem = Char}
  spec CharEndoList = EndoList with {Elem = Char; List = CharList}
  CharEndoList = load EndoList with {Elem = Char; List = CharList}
  spec String =
  ~CharEndoList ->
    sig
      value eq : ~l:CharList.t ~k:CharList.t -> [`True|`False]
      value up : CharList.t
      value it : CharList.t
      value a : Char.t
      value prefix_by_a : ~tail:CharList.t -> CharList.t
      value shout : ~l:CharList.t -> CharList.t
    end
  String = 
    :: String
struct
      value eq = fun ~l ~k -> match CharList.list ~it:l with
        fold [`Nil -> {} . `True
              |`Cons ht -> {} . `True]
      value up = CharList.cons ~head:Char.c_a 
                   ~tail:(CharList.cons ~head:Char.c_b
			    ~tail:CharList.nil)
      value it = CharList.cons ~head:Char.c_c 
                   ~tail:(CharList.cons ~head:Char.c_a 
                            ~tail:(CharList.cons ~head:Char.c_b
				     ~tail:CharList.nil))
      value a = Char.c_a
      value prefix_by_a = fun ~tail -> 
        CharList.cons ~head:Char.c_a ~tail
      value shout = fun ~l -> CharEndoList.mapt ~l 
                                 ~f:fun ~e -> Char.upper ~it:e  
    end
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value up : t
      value it : t
      value prim : ~it:t -> t
    end
  Index =
    :: ~String -> Index
struct
      type t = CharList.t
      value eq = fun ~i ~j -> String.eq ~l:i ~k:j
      value up = String.up
      value it = String.it
      value prim = fun ~it -> 
        CharEndoList.append ~it 
          ~l:(CharList.cons ~head:Char.c_quote 
                ~tail:CharList.nil)
    end
  spec IList = 
  ~Index ~Value:T ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~t:t -> t
      value find : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
    end
  spec IElem = 
  ~Index ~Value: T -> 
    sig
      type t
      value i : ~it:t -> Index.t
      value v : ~it:t -> Value.t
      value assoc : ~i:Index.t ~v:Value.t -> t
    end
  library IElem = 
    :: IElem
struct
      type t = {i: Index.t; v: Value.t}
      value i = fun ~it -> it.i
      value v = fun ~it -> it.v
      value assoc = fun ~i ~v -> {i; v}
    end
  spec IElemList = List with {Elem = IElem}
  library IList = 
    :: ~IElemList -> IList
struct
      type t = IElemList.t
      value nil = IElemList.nil
      value cons = fun ~i ~v ~t -> 
        IElemList.cons ~tail:t ~head:(IElem.assoc ~i ~v)
      value find = 
        fun ~i ~l -> 
          match IElemList.list ~it:l with
            fold [`Nil -> {} . `Error
                  |`Cons ht -> 
                     match Index.eq ~i:i 
                             ~j:(IElem.i ~it:ht.head) with
		       [`True -> (IElem.v 
                                         ~it:ht.head).`OK
                       |`False -> ht.tail]]
    end
  spec LDule =
  ~Index ->
    sig
      type cat
      type funct
      value cat : ~it:cat -> 
        ind cat: [`BB
                 |`OP cat
                 |`SRC funct]
      value funct : ~it:funct -> 
        ind funct: [`OP funct
	           |`PP ind il: 
                     [`Nil|`Cons {i: Index.t; head: funct; tail: il}]
		   |`ID cat]
      value c_bb : cat
      value c_op : ~it:cat -> cat
      value c_src : ~it:funct -> cat
      value f_op : ~it:funct -> funct
      value f_pp : ~it:ind il: 
        [`Nil|`Cons {i: Index.t; head: funct; tail: il}] -> funct
      value f_id : ~it:cat -> funct
    end
  LDule = 
    :: LDule
struct
      type cat = 
        ind cat: [`BB
                 |`OP cat
		 |`SRC ind funct: [`OP funct
	           |`PP ind il: 
                     [`Nil|`Cons {i: Index.t; head: funct; tail: il}]
	           |`ID cat]]
      type funct =
        ind funct: [`OP funct
	           |`PP ind il: 
                     [`Nil|`Cons {i: Index.t; head: funct; tail: il}]
	           |`ID ind cat: [`BB
                 |`OP cat
		 |`SRC ind funct: [`OP funct
	           |`PP ind il: 
                     [`Nil|`Cons {i: Index.t; head: funct; tail: il}]
	           |`ID cat]]]
      value cat = fun ~it -> it . `ID . con . `SRC . con
      value funct = fun ~it -> it
      value c_bb = {} . `BB . con
      value c_op = fun ~it -> it . `OP . con
      value c_src = fun ~it -> it . `SRC . con
      value f_op = fun ~it -> it . `OP . con
      value f_pp = fun ~it -> it . `PP . con
      value f_id = fun ~it -> it . `ID . con
    end
  spec ValueFunct = ~LDule -> T
  library ValueFunct = 
struct
      type t = LDule.funct
    end
  spec LDule_IElem = IElem with {Value = load ValueFunct; Index}
  LDule_IElem = load IElem with {Value = load ValueFunct; Index}
  spec LDule_IList2 = 
~LDule_IElem -> IList with {Value = load ValueFunct; Index}
end

Lo_prog44 =  
link
  spec T = sig type t end
  spec Elem = sig type t end
  spec List = 
  ~Elem: T ->
    sig
      type t
      value cons : ~head:Elem.t ~tail:t -> t
    end
  spec LCat =
    sig
      type cat
      type c_ilist
      value cons : ~head:{v: cat} ~tail:c_ilist -> c_ilist
    end
  LCat = 
    :: LCat
struct
      type cat = 
        ind cat: [`PP ind lc: [`Nil
                             |`Cons {head:{v: cat};
				      tail:lc}]
                 |`BB]
      type c_ilist = ind lc: [`Nil
                             |`Cons {head:{v: ind cat: [`PP ind lc: [`Nil
                             |`Cons {head:{v: cat};
				      tail:lc}]|`BB]};
				      tail:lc}]
      value cons = fun ~head ~tail -> {head; tail} . `Cons . con
    end
  spec LCatElem = ~LCat -> T
  library LCatElem = 
    :: LCatElem
struct
      type t = {v: LCat.cat}
    end
  spec LCatList = List with {Elem = load LCatElem}
  LCatList = 
    :: LCatList
struct
      type t = LCat.c_ilist
      value cons = LCat.cons
    end
end

Lo_prog48 =  
link
  spec Nat =
    sig
      type t
      value nat : ~n:t -> 
	ind nat: [`Zero|`Succ nat]
      value zero : t
      value succ : ~n:t -> t
      value is_zero : ~it:t -> [`True|`False]
      value plus : ~n:t ~m:t -> t
    end
  Nat = 
    struct
      type t = ind nat: [`Zero|`Succ nat]
      value nat = fun ~n -> n
      value zero = `Zero . con
      value succ = fun ~n -> n .`Succ . con
      value is_zero = 
        fold [`Zero -> `True
              |`Succ -> `False]
      value plus = fun ~m ~n -> 
	match n with
        fold [`Zero -> m
              |`Succ nn -> nn .`Succ . con]
    end
  spec Elem = sig type t end
  spec List = 
  ~Elem ->
    sig
      type t
      value list : ~l:t ->
        ind list: [`Nil|`Cons {head: Elem.t; tail: list}]
      value de_list : ~l:t -> 
	[`Nil|`Cons {head: Elem.t; tail: t}]
      value nil : t
      value cons : ~head:Elem.t ~tail:t -> t
    end
  library List =
    struct
      type t = ind list: [`Nil|`Cons {head: Elem.t; tail: list}]
      value list = fun ~l -> l
      value de_list = fun ~l -> l . de
      value nil = `Nil . con
      value cons = fun ~head ~tail -> {head; tail} .`Cons . con
    end
  spec ListMap = 
  ~List ->
    sig
      value map1 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map2 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map3 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map4 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map5 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t
    end
  library ListMap =
    struct
      value map1 = 
        fun ~f ~l -> 
	  match List.list ~l with
          fold [`Nil -> List.nil
                |`Cons ht -> List.cons ~head:(f ~e:ht.head) ~tail:ht.tail]
      value map2 = 
        fun ~f ~l -> 
          (fold [`Nil fun ~f ~it -> List.nil
                |`Cons fun ~f ~it -> 
                   List.cons ~head:(f ~e:it.head) ~tail:it.tail])
	    ~f ~it:(List.list ~l)
      value map3 = 
	let consf = fun ~(f: ~e:Elem.t -> Elem.t) ~it:ht -> 
          List.cons ~head:(f ~e:ht.head) ~tail:ht.tail in
        fun ~f ~l -> 
          (fold [`Nil fun ~(f: ~e:Elem.t -> Elem.t) ~it -> List.nil
                |`Cons consf])
	    ~f ~it:(List.list ~l)
      value map4 = 
	let consf = fun ~f -> fun ~ht -> 
          List.cons ~head:(f ~e:ht.head) ~tail:ht.tail in
        fun ~f ~l -> 
          match List.list ~l with
          fold [`Nil -> List.nil
               |`Cons it -> (consf ~f) ~ht:it]
      value map5 = 
        fun ~f ~l -> 
	  let consf = fun ~it:ht -> 
            List.cons ~head:(f ~e:ht.head) ~tail:ht.tail in
          match List.list ~l with
          fold [`Nil -> List.nil
                |`Cons consf]
    end
  spec NatList = List with {Elem = Nat}
  NatList = load List with {Elem = Nat}
  spec ToolNatList =
  ~NatList -> 
    sig 
      value hd : ~l:NatList.t -> [`OK Nat.t|`Error]
      value do_at_tail : ~f: ~l:NatList.t -> [`OK Nat.t|`Error] ->
	                   ~l:NatList.t -> [`OK Nat.t|`Error]
      value list_first : ~n:Nat.t -> {l: NatList.t; n: Nat.t}
      value three : Nat.t
      value nz_plus : ~n:Nat.t -> ~e:Nat.t -> Nat.t
    end
  ToolNatList =
    struct 
      value hd = fun ~l ->
        match NatList.de_list ~l with
        [`Nil -> `Error
 	|`Cons ht -> ht.head .`OK]
      value do_at_tail = fun ~f -> fun ~l ->
        match NatList.de_list ~l with
        [`Nil -> `Error
 	|`Cons ht -> f ~l:ht.tail] 
      value list_first = fun ~n ->
	match Nat.nat ~n with
        fold [`Zero -> {l= NatList.nil; n= Nat.zero}
              |`Succ lxn -> {l= NatList.cons ~head:lxn.n ~tail:lxn.l;
			    n= Nat.succ ~n:lxn.n}]
      value three = Nat.succ ~n:(Nat.succ ~n:(Nat.succ ~n:Nat.zero))
      value nz_plus = fun ~n -> fun ~e ->
	match Nat.is_zero ~it:e with
	[`True -> e
        |`False -> Nat.plus ~m:e ~n]
    end
  spec NatListMap = ListMap with {Elem = Nat; List = NatList}
  NatListMap = load ListMap with {Elem = Nat; List = NatList}
  spec Test = 
  ~ToolNatList ~NatListMap -> 
    sig 
      value test : NatList.t
    end
  Test =
    struct 
      value test = NatListMap.map1
	~f:(ToolNatList.nz_plus ~n:ToolNatList.three)
	~l:(ToolNatList.list_first ~n:ToolNatList.three).l
    end
  spec Tests = 
  ~Nat ->
    sig 
      value test_5 : [`OK Nat.t|`Error]
      value test_4 : [`OK Nat.t|`Error]
      value test_0 : [`OK Nat.t|`Error]
    end
  Tests =
    :: ~Test -> Tests
    struct 
      value test_5 = ToolNatList.hd ~l:Test.test
      value test_4 = (ToolNatList.do_at_tail ~f:ToolNatList.hd) ~l:Test.test
      value test_0 = (ToolNatList.do_at_tail 
			~f:(ToolNatList.do_at_tail 
			      ~f:ToolNatList.hd)) 
	               ~l:Test.test
    end
end

Lo_prog49 =  
link
  spec Nat =
    sig
      type t
      value nat : ~n:t -> 
	ind nat: [`Zero|`Succ nat]
      value zero : t
      value succ : ~n:t -> t
      value is_zero : ~it:t -> [`True|`False]
      value plus : ~n:t ~m:t -> t
    end
  Nat = 
    struct
      type t = ind nat: [`Zero|`Succ nat]
      value nat = fun ~n -> n
      value zero = `Zero . con
      value succ = fun ~n -> n .`Succ . con
      value is_zero = 
        fold [`Zero -> `True
              |`Succ -> `False]
      value plus = fun ~m ~n -> 
	match n with
        fold [`Zero -> m
              |`Succ nn -> nn .`Succ . con]
    end
  spec Elem = sig type t end
  spec List = 
  ~Elem ->
    sig
      type t
      value list : ~l:t ->
        ind list: [`Nil|`Cons {head: Elem.t; tail: list}]
      value de_list : ~l:t -> 
	[`Nil|`Cons {head: Elem.t; tail: t}]
      value nil : t
      value cons : ~head:Elem.t ~tail:t -> t
    end
  library List =
    struct
      type t = ind list: [`Nil|`Cons {head: Elem.t; tail: list}]
      value list = fun ~l -> l
      value de_list = fun ~l -> l . de
      value nil = `Nil . con
      value cons = fun ~head ~tail -> {head; tail} .`Cons . con
    end
  spec ListMap = 
  ~List ->
    sig
      value map1 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map2 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map3 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map4 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value map5 : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t
    end
  library ListMap =
    struct
      value map1 = 
        fun ~f ~l -> 
	  match List.list ~l with
          fold [`Nil -> List.nil
               |`Cons ht -> List.cons ~head:(f ~e:ht.head) ~tail:ht.tail]
      value map2 = 
        fun ~f ~l -> 
          (fold [`Nil fun ~f ~it -> List.nil
                 |`Cons fun ~f ~it:ht -> 
                    List.cons ~head:(f ~e:ht.head) ~tail:ht.tail])
	    ~f ~it:(List.list ~l)
      value map3 = 
	let consf = fun ~(f: ~e:Elem.t -> Elem.t) ~ht -> 
          List.cons ~head:(f ~e:ht.head) ~tail:ht.tail in
        fun ~f ~l -> 
          (fold [`Nil fun ~(f: ~e:Elem.t -> Elem.t) ~it -> List.nil
                |`Cons fun ~(f: ~e:Elem.t -> Elem.t) ~it -> consf ~f ~ht:it])
	    ~f ~it:(List.list ~l)
      value map4 = 
	let consf = fun ~f -> fun ~it:ht -> 
          List.cons ~head:(f ~e:ht.head) ~tail:ht.tail in
        fun ~f ~l -> 
          match List.list ~l with
          fold [`Nil -> List.nil
               |`Cons (consf ~f)]
      value map5 = 
        fun ~f ~l -> 
	  let consf = fun ~it:ht -> 
            List.cons ~head:(f ~e:ht.head) ~tail:ht.tail in
          match List.list ~l with
          fold [`Nil -> List.nil
                |`Cons consf]
    end
  library ArgsNatList = {Elem = Nat}
  spec NatList = List with load ArgsNatList
  NatList = load List with load ArgsNatList
  spec ToolNatList =
  ~NatList -> 
    sig 
      value hd : ~l:NatList.t -> [`OK Nat.t|`Error]
      value do_at_tail : ~f: ~l:NatList.t -> [`OK Nat.t|`Error] ->
	                   ~l:NatList.t -> [`OK Nat.t|`Error]
      value list_first : ~n:Nat.t -> {l: NatList.t; n: Nat.t}
      value three : Nat.t
      value nz_plus : ~n:Nat.t -> ~e:Nat.t -> Nat.t
    end
  ToolNatList =
    struct 
      value hd = fun ~l ->
        match NatList.de_list ~l with
        [`Nil -> `Error
 	|`Cons ht -> ht.head .`OK]
      value do_at_tail = fun ~f -> fun ~l ->
        match NatList.de_list ~l with
        [`Nil -> `Error
 	|`Cons ht -> f ~l:ht.tail] 
      value list_first = fun ~n ->
	match Nat.nat ~n with
        fold [`Zero -> {l= NatList.nil; n= Nat.zero}
              |`Succ lxn -> {l= NatList.cons ~head:lxn.n ~tail:lxn.l;
			    n= Nat.succ ~n:lxn.n}]
      value three = Nat.succ ~n:(Nat.succ ~n:(Nat.succ ~n:Nat.zero))
      value nz_plus = fun ~n -> fun ~e ->
	match Nat.is_zero ~it:e with
	[`True -> e
        |`False -> Nat.plus ~m:e ~n]
    end
  library ArgsNatListMap = {Elem = Nat; List = NatList}
  spec NatListMap = ListMap with load ArgsNatListMap
  NatListMap = load ListMap with load ArgsNatListMap
  spec Test = 
  ~ToolNatList ~NatListMap -> 
    sig 
      value test : NatList.t
    end
  Test =
    struct 
      value test = NatListMap.map1
	~f:(ToolNatList.nz_plus ~n:ToolNatList.three)
	~l:(ToolNatList.list_first ~n:ToolNatList.three).l
    end
  spec Tests = 
  ~Nat ->
    sig 
      value test_5 : [`OK Nat.t|`Error]
      value test_4 : [`OK Nat.t|`Error]
      value test_0 : [`OK Nat.t|`Error]
    end
  Tests =
    :: ~Test -> Tests
    struct 
      value test_5 = ToolNatList.hd ~l:Test.test
      value test_4 = (ToolNatList.do_at_tail ~f:ToolNatList.hd) ~l:Test.test
      value test_0 = (ToolNatList.do_at_tail 
			~f:(ToolNatList.do_at_tail 
			      ~f:ToolNatList.hd)) 
	               ~l:Test.test
    end
end

Lo_prog491 =  
link
  spec Nat =
    sig
      type t
      value zero : t
    end
  Nat = 
    struct
      type t = [`Zero]
      value zero = `Zero
    end
end

Lo_progtest11149 =  
link
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end
  spec Cat =
  ~Index ->
    sig
    end
  module Cat = 
    struct
    end
end

Lo_progtest11 =  
link
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList = struct type t = {} value nil = {} end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value de_cat : ~c:t ->
	       [`PP CatIList.t
               |`BB]
    end
  module ind CatIList = load IList with {{Value = Cat}}
  and Cat = 
    struct
      type t = 
	ind t: [`PP CatIList.t
               |`BB]
      value de_cat = fun ~c -> c . de
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
      value ind_funct : ~f:t -> 
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
    end
  module ind FunctIList = load IList with {{Value = Funct}}
  and Funct =
    struct
      type t =
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value ind_funct = fun ~f -> f
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
      value t_ID : ~c:Cat.t -> t
    end
  module ind TransIList = load IList with {{Value = Trans}}
  and Trans = 
    struct
      type t = 
        ind t: [`T_ID Cat.t]
      value t_ID = fun ~c -> c .`T_ID . con
    end
  spec EqCat =
  ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  EqCat =
    struct
      value eq_cat = fun ~c1 ~c2 -> `True
    end
  spec ToolCat =
  ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolCat =
    :: ~EqCat -> ToolCat
    struct
      value append_ok = fun ~l1 ~l2 -> `Error
      value diff = fun ~l1 ~l2 -> l1
      value inter = fun ~l1 ~l2 -> l1
    end
  spec EqFunct =
  ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  EqFunct =
    struct
      value eq_funct = fun ~f1 ~f2 -> `True
    end
  spec ToolFunct =
  ~Funct ->
    sig
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolFunct =
    :: ~EqFunct -> ToolFunct
    struct
      value append_ok = fun ~l1 ~l2 -> `Error
      value seteq = fun ~l1 ~l2 -> `True
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  module SrcDule =
    :: ~ToolCat -> SrcDule
    struct
      value unPP = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc
	|`BB -> CatIList.nil]
      value unPPok = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc .`OK
	|`BB -> `Error ]
    end
  spec DomDule =
  ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {} 
    end
  DomDule =
    struct
      value dom = fun ~t -> {}
      value cod = fun ~t -> {}
    end
  spec ToolSCat =
  ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolSCat =
    :: ~ToolCat -> ToolSCat
    struct
      value append_ok = ToolCat.append_ok
      value diff = ToolCat.diff
      value inter = ToolCat.inter
    end
  spec ToolSFunct =
  ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolSFunct =
  :: ~ToolFunct -> ToolSFunct
    struct
      value bfold1ok = fun
        ~(init:FunctIList.t)
        ~(f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error])
        ~(l:FunctIList.t)
          -> `Error
      value imap_cf = fun ~(f: ~i:Index.t -> Funct.t) ~(l:CatIList.t) ->
	FunctIList.nil
      value imap_fc = fun ~(f: ~i:Index.t -> Cat.t) ~(l:FunctIList.t) ->
	CatIList.nil
      value bmap1ok_cf = fun
	~(f: ~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~(l:CatIList.t) ->
          `Error
      value ifold1ok_fc = fun
        ~(init:CatIList.t)
        ~(f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error])
        ~(l:FunctIList.t)
          -> `Error
      value append_ok = ToolFunct.append_ok
      value seteq = ToolFunct.seteq
    end
  spec ToolSTrans =
  ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  ToolSTrans = 
    struct
      value vmap_tf = fun ~(f: ~v:Trans.t -> Funct.t) ~(l:TransIList.t) ->
	FunctIList.nil
      value bmap1ok_ft = 
	fun ~(f: ~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) 
	    ~(l:FunctIList.t) -> `Error
    end
  library SLink =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec EqCat = ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat = ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec EqFunct = ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct = ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec ToolSTrans = ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec DomDule = ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {} 
    end
  spec ToolSSign = 
  ~Trans ->
    sig
    end
  ToolSSign =
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~DomDule -> ToolSSign
    struct
    end
  spec OkSSign = 
  ~Funct ->
    sig
    end
  OkSSign = 
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~ToolSSign -> OkSSign
    struct
    end
  spec SemSSign =
  ~Trans ->
    sig
    end
  SemSSign = 
    :: ~ToolSFunct ~ToolSSign ~OkSSign -> SemSSign
    struct
    end
  spec ToolSDule = 
  ~Trans ->
    sig
    end
  ToolSDule = 
    :: ~SrcDule ~DomDule -> ToolSDule
    struct
    end
  spec OkSDule = 
  ~Trans ->
    sig
    end
  OkSDule = 
    :: ~EqCat ~ToolSCat ~EqFunct ~ToolSFunct ~ToolSTrans 
       ~SrcDule ~DomDule ~ToolSSign -> OkSDule
    struct
    end
  spec SemSDule =
  ~Trans ->
    sig
    end
  SemSDule = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~ToolSSign ~OkSSign ~ToolSDule ~OkSDule ->
         SemSDule
    struct
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  SemSLink = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~SemSSign ~ToolSDule ~SemSDule -> SemSLink
    struct
      value m_Accord = fun ~lr ~lm ~ls ->
	`Error
      value m_Concord = fun ~lr ~lm ~ls ->
	`Error
      value m_Link = fun ~lr ~lm ~ls ->
	`Error
    end
end
  SLink_on_LDule = load SLink with 
    {{EqCat; 
     ToolSCat;
     EqFunct; 
     ToolSFunct;
     ToolSTrans;
     SrcDule; DomDule}}
  library SInd =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec EqCat = ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat = ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec EqFunct = ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct = ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec ToolSTrans = ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec DomDule = ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {} 
    end
  spec SemSSign =
  ~Trans ->
    sig
    end
  spec ToolSDule = 
  ~Trans ->
    sig
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  spec ToolSInd = 
  ~Trans ->
    sig
    end
  ToolSInd =
    :: ~SrcDule ~DomDule -> ToolSInd
    struct
    end 
  spec SemSInd =
  ~Trans ->
    sig
      value m_Ind : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  SemSInd =
    :: ~SrcDule ~DomDule ~SemSSign ~ToolSDule ~SemSLink ~ToolSInd -> SemSInd
    struct
      value m_Ind = fun ~lr ~lm ~ls ->
	`Error
    end
end
  SemSSign = SLink_on_LDule . SemSSign
  ToolSDule = SLink_on_LDule | ToolSDule
  SInd_on_LDule = load SInd with 
    {{SemSSign; ToolSDule;
 SemSLink = SLink_on_LDule | SemSLink; DomDule; SrcDule}}
end | SInd_on_LDule

Lo_progtest111 =  
link
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList = struct type t = {} value nil = {} end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value de_cat : ~c:t ->
	       [`PP CatIList.t
               |`BB]
    end
  module ind CatIList = load IList with {{Value = Cat}}
  and Cat = 
    struct
      type t = 
	ind t: [`PP CatIList.t
               |`BB]
      value de_cat = fun ~c -> c . de
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
      value ind_funct : ~f:t -> 
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
    end
  module ind FunctIList = load IList with {{Value = Funct}}
  and Funct =
    struct
      type t =
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value ind_funct = fun ~f -> f
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
      value t_ID : ~c:Cat.t -> t
    end
  module ind TransIList = load IList with {{Value = Trans}}
  and Trans = 
    struct
      type t = 
        ind t: [`T_ID Cat.t]
      value t_ID = fun ~c -> c .`T_ID . con
    end
  spec EqCat =
  ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  EqCat =
    struct
      value eq_cat = fun ~c1 ~c2 -> `True
    end
  spec ToolCat =
  ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolCat =
    :: ~EqCat -> ToolCat
    struct
      value append_ok = fun ~l1 ~l2 -> `Error
      value diff = fun ~l1 ~l2 -> l1
      value inter = fun ~l1 ~l2 -> l1
    end
  spec EqFunct =
  ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  EqFunct =
    struct
      value eq_funct = fun ~f1 ~f2 -> `True
    end
  spec ToolFunct =
  ~Funct ->
    sig
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolFunct =
    :: ~EqFunct -> ToolFunct
    struct
      value append_ok = fun ~l1 ~l2 -> `Error
      value seteq = fun ~l1 ~l2 -> `True
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  module SrcDule =
    :: ~ToolCat -> SrcDule
    struct
      value unPP = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc
	|`BB -> CatIList.nil]
      value unPPok = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc .`OK
	|`BB -> `Error ]
    end
  spec DomDule =
  ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {} 
    end
  DomDule =
    struct
      value dom = fun ~t -> {}
      value cod = fun ~t -> {}
    end
  spec ToolSCat =
  ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolSCat =
    :: ~ToolCat -> ToolSCat
    struct
      value append_ok = ToolCat.append_ok
      value diff = ToolCat.diff
      value inter = ToolCat.inter
    end
  spec ToolSFunct =
  ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolSFunct =
  :: ~ToolFunct -> ToolSFunct
    struct
      value bfold1ok = fun
        ~(init:FunctIList.t)
        ~(f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error])
        ~(l:FunctIList.t)
          -> `Error
      value imap_cf = fun ~f ~l ->
	FunctIList.nil
      value imap_fc = fun ~f ~l ->
	CatIList.nil
      value bmap1ok_cf = fun
	~f ~(l:CatIList.t) ->
          `Error
      value ifold1ok_fc = fun
        ~init
        ~f
        ~l
          -> `Error
      value append_ok = ToolFunct.append_ok
      value seteq = ToolFunct.seteq
    end
  spec ToolSTrans =
  ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  ToolSTrans = 
    struct
      value vmap_tf = fun ~(f: ~v:Trans.t -> Funct.t) ~l ->
	FunctIList.nil
      value bmap1ok_ft = 
	fun ~f
	    ~l -> `Error
    end
  library SLink =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec EqCat = ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat = ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec EqFunct = ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct = ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec ToolSTrans = ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec DomDule = ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {} 
    end
  spec ToolSSign = 
  ~Trans ->
    sig
    end
  ToolSSign =
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~DomDule -> ToolSSign
    struct
    end
  spec OkSSign = 
  ~Funct ->
    sig
    end
  OkSSign = 
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~ToolSSign -> OkSSign
    struct
    end
  spec SemSSign =
  ~Trans ->
    sig
    end
  SemSSign = 
    :: ~ToolSFunct ~ToolSSign ~OkSSign -> SemSSign
    struct
    end
  spec ToolSDule = 
  ~Trans ->
    sig
    end
  ToolSDule = 
    :: ~SrcDule ~DomDule -> ToolSDule
    struct
    end
  spec OkSDule = 
  ~Trans ->
    sig
    end
  OkSDule = 
    :: ~EqCat ~ToolSCat ~EqFunct ~ToolSFunct ~ToolSTrans 
       ~SrcDule ~DomDule ~ToolSSign -> OkSDule
    struct
    end
  spec SemSDule =
  ~Trans ->
    sig
    end
  SemSDule = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~ToolSSign ~OkSSign ~ToolSDule ~OkSDule ->
         SemSDule
    struct
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  SemSLink = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~SemSSign ~ToolSDule ~SemSDule -> SemSLink
    struct
      value m_Accord = fun ~lr ~lm ~ls ->
	`Error
      value m_Concord = fun ~lr ~lm ~ls ->
	`Error
      value m_Link = fun ~lr ~lm ~ls ->
	`Error
    end
end
  SLink_on_LDule = load SLink with 
    {{EqCat; 
     ToolSCat;
     EqFunct; 
     ToolSFunct;
     ToolSTrans;
     SrcDule; DomDule}}
  library SInd =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec EqCat = ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat = ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec EqFunct = ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct = ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec ToolSTrans = ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec DomDule = ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {} 
    end
  spec SemSSign =
  ~Trans ->
    sig
    end
  spec ToolSDule = 
  ~Trans ->
    sig
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  spec ToolSInd = 
  ~Trans ->
    sig
    end
  ToolSInd =
    :: ~SemSLink -> ToolSInd
    struct
    end 
end
  SemSSign = SLink_on_LDule . SemSSign
  SInd_on_LDule = load SInd with 
    {{SemSLink = SLink_on_LDule | SemSLink; Trans}}
end

Lo_progtest12 =  
link
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList = struct type t = {} value nil = {} end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value de_cat : ~c:t ->
	       [`PP CatIList.t
               |`BB]
    end
  module ind CatIList = load IList with {{Value = Cat}}
  and Cat = 
    struct
      type t = 
	ind t: [`PP CatIList.t
               |`BB]
      value de_cat = fun ~c -> c . de
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
      value ind_funct : ~f:t -> 
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
    end
  module ind FunctIList = load IList with {{Value = Funct}}
  and Funct =
    struct
      type t =
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value ind_funct = fun ~f -> f
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
      value t_ID : ~c:Cat.t -> t
    end
  module ind TransIList = load IList with {{Value = Trans}}
  and Trans = 
    struct
      type t = 
        ind t: [`T_ID Cat.t]
      value t_ID = fun ~c -> c .`T_ID . con
    end
  spec EqCat =
  ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  EqCat =
    struct
      value eq_cat = fun ~c1 ~c2 -> `True
    end
  spec ToolCat =
  ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolCat =
    :: ~EqCat -> ToolCat
    struct
      value append_ok = fun ~l1 ~l2 -> `Error
      value diff = fun ~l1 ~l2 -> l1
      value inter = fun ~l1 ~l2 -> l1
    end
  spec EqFunct =
  ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  EqFunct =
    struct
      value eq_funct = fun ~f1 ~f2 -> `True
    end
  spec ToolFunct =
  ~Funct ->
    sig
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolFunct =
    :: ~EqFunct -> ToolFunct
    struct
      value append_ok = fun ~l1 ~l2 -> `Error
      value seteq = fun ~l1 ~l2 -> `True
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  module SrcDule =
    :: ~ToolCat -> SrcDule
    struct
      value unPP = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc
	|`BB -> CatIList.nil]
      value unPPok = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc .`OK
	|`BB -> `Error ]
    end
  spec DomDule =
  ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {}
    end
  DomDule =
    struct
      value dom = fun ~t -> {}
      value cod = fun ~t -> {}
    end
  spec ToolSCat =
  ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  ToolSCat =
    :: ~ToolCat -> ToolSCat
    struct
      value append_ok = ToolCat.append_ok
      value diff = ToolCat.diff
      value inter = ToolCat.inter
    end
  spec ToolSFunct =
  ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  ToolSFunct =
  :: ~ToolFunct -> ToolSFunct
    struct
      value bfold1ok = fun
        ~(init:FunctIList.t)
        ~f
        ~l -> `Error
      value imap_cf = fun ~(f: ~i:Index.t -> Funct.t) ~(l:CatIList.t) ->
	FunctIList.nil
      value imap_fc = fun ~f ~(l:FunctIList.t) ->
	CatIList.nil
      value bmap1ok_cf = fun
	~(f: ~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l ->
          `Error
      value ifold1ok_fc = fun
        ~init
        ~f
        ~l
          -> `Error
      value append_ok = ToolFunct.append_ok
      value seteq = ToolFunct.seteq
    end
  spec ToolSTrans =
  ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  ToolSTrans = 
    struct
      value vmap_tf = fun ~f ~(l:TransIList.t) ->
	FunctIList.nil
      value bmap1ok_ft = 
	fun ~(f: ~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) 
	    ~l -> `Error
    end
  library SLink =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec EqCat = ~Cat ->
    sig
      value eq_cat : ~c1: Cat.t ~c2: Cat.t -> [`True|`False]
    end
  spec ToolSCat = ~Cat ->
    sig
      value append_ok : 
	~l1:CatIList.t ~l2:CatIList.t -> [`OK CatIList.t|`Error]
      value diff : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
      value inter : 
	~l1:CatIList.t ~l2:CatIList.t -> CatIList.t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec EqFunct = ~Funct ->
    sig
      value eq_funct : ~f1:Funct.t ~f2:Funct.t -> [`True|`False]        
    end
  spec ToolSFunct = ~Funct ->
    sig
      value bfold1ok : 
        ~init:FunctIList.t
        ~f: ~i:Index.t ~v:Funct.t ~r:[`OK FunctIList.t|`Error] ->
          [`OK FunctIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK FunctIList.t|`Error]         
      value imap_cf : ~f: ~i:Index.t -> Funct.t ~l:CatIList.t -> FunctIList.t
      value imap_fc : ~f: ~i:Index.t -> Cat.t ~l:FunctIList.t -> CatIList.t
      value bmap1ok_cf :
	~f: (~i:Index.t ~v:Cat.t -> [`OK Funct.t|`Error]) ~l:CatIList.t ->
          [`OK FunctIList.t|`Error]
      value ifold1ok_fc : 
        ~init:CatIList.t
        ~f: ~i:Index.t ~r:[`OK CatIList.t|`Error] -> [`OK CatIList.t|`Error]
        ~l:FunctIList.t
          -> [`OK CatIList.t|`Error]         
      value append_ok : 
	~l1:FunctIList.t ~l2:FunctIList.t -> [`OK FunctIList.t|`Error]
      value seteq : ~l1:FunctIList.t ~l2:FunctIList.t -> [`True|`False]
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec ToolSTrans = ~Trans ->
    sig
      value vmap_tf : 
	~f: ~v:Trans.t -> Funct.t ~l:TransIList.t -> FunctIList.t
      value bmap1ok_ft :
	~f: (~i:Index.t ~v:Funct.t -> [`OK Trans.t|`Error]) ~l:FunctIList.t ->
          [`OK TransIList.t|`Error]
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec DomDule = ~Trans -> 
    sig
      value dom : ~t:Trans.t -> {}
      value cod : ~t:Trans.t -> {}
    end
  spec ToolSSign = 
  ~Trans ->
    sig
    end
  ToolSSign =
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~DomDule -> ToolSSign
    struct
    end
  spec OkSSign = 
  ~Funct ->
    sig
    end
  OkSSign = 
    :: ~ToolSCat ~ToolSFunct ~SrcDule ~ToolSSign -> OkSSign
    struct
    end
  spec SemSSign =
  ~Trans ->
    sig
    end
  SemSSign = 
    :: ~ToolSFunct ~ToolSSign ~OkSSign -> SemSSign
    struct
    end
  spec ToolSDule = 
  ~Trans ->
    sig
    end
  ToolSDule = 
    :: ~SrcDule ~DomDule -> ToolSDule
    struct
    end
  spec OkSDule = 
  ~Trans ->
    sig
    end
  OkSDule = 
    :: ~EqCat ~ToolSCat ~EqFunct ~ToolSFunct ~ToolSTrans 
       ~SrcDule ~DomDule ~ToolSSign -> OkSDule
    struct
    end
  spec SemSDule =
  ~Trans ->
    sig
    end
  SemSDule = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~ToolSSign ~OkSSign ~ToolSDule ~OkSDule ->
         SemSDule
    struct
    end
  spec SemSLink =
  ~Trans ->
    sig
      value m_Accord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Concord : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
      value m_Link : ~lr:FunctIList.t ~lm:TransIList.t ~ls:FunctIList.t ->
	[`OK Trans.t|`Error]
    end
  SemSLink = 
    :: ~ToolSTrans ~SrcDule ~DomDule ~SemSSign ~ToolSDule ~SemSDule -> SemSLink
    struct
      value m_Accord = fun ~lr ~lm ~ls ->
	`Error
      value m_Concord = fun ~lr ~lm ~ls ->
	`Error
      value m_Link = fun ~lr ~lm ~ls ->
	`Error
    end
end
  SLink_on_LDule = load SLink with 
    {{EqCat; 
     ToolSCat;
     EqFunct; 
     ToolSFunct;
     ToolSTrans;
     SrcDule; DomDule}}
  library SInd =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec SemSInd =
  ~Trans ->
    sig
    end
  SemSInd =
    :: ~SrcDule -> SemSInd
    struct
    end
end
  SemSLink = SLink_on_LDule | SemSLink
  SemSSign = SLink_on_LDule . SemSSign
  ToolSDule = SLink_on_LDule | ToolSDule
  SInd_on_LDule = load SInd with 
    {{SemSSign; ToolSDule; SemSLink; SrcDule; Trans}}
end | SemSSign

Lo_progtest13 =  
link
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList = struct type t = {} value nil = {} end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value de_cat : ~c:t ->
	       [`PP CatIList.t
               |`BB]
    end
  module ind CatIList = load IList with {{Value = Cat}}
  and Cat = 
    struct
      type t = 
	ind t: [`PP CatIList.t
               |`BB]
      value de_cat = fun ~c -> c . de
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
      value ind_funct : ~f:t -> 
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
    end
  module ind FunctIList = load IList with {{Value = Funct}}
  and Funct =
    struct
      type t =
        ind t: [`F_ID Cat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {lc : CatIList.t; i : Index.t}
	       |`F_RECORD {c : Cat.t; lf : FunctIList.t}
	       |`F_pp {c : Cat.t; lf : FunctIList.t}
	       |`F_ss {c : Cat.t; lf : FunctIList.t}
	       |`F_ee {lf : FunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value ind_funct = fun ~f -> f
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
      value t_ID : ~c:Cat.t -> t
    end
  module ind TransIList = load IList with {{Value = Trans}}
  and Trans = 
    struct
      type t = 
        ind t: [`T_ID Cat.t]
      value t_ID = fun ~c -> c .`T_ID . con
    end
  spec SrcDule =
  ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  module SrcDule =
    struct
      value unPP = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc
	|`BB -> CatIList.nil]
      value unPPok = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc .`OK
	|`BB -> `Error ]
    end
  library SLink =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec ToolSDule = 
  ~Trans ~SrcDule ->
    sig
    end
  ToolSDule = 
    :: ~SrcDule  -> ToolSDule
    struct
    end
end
  SLink_on_LDule = load SLink with 
    {{SrcDule; Trans}}
  library SInd =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec rec FunctIList = IList with {{Value = Funct}}
  and Funct =
  ~Cat ->
    sig
      type t
    end
  spec rec TransIList = IList with {{Value = Trans}}
  and Trans =
  ~Funct ->
    sig
      type t
    end
  spec SrcDule = ~Funct -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
      value unPPok : ~c:Cat.t -> [`OK CatIList.t|`Error]
    end
  spec SemSInd =
  ~Trans ->
    sig
    end
  SemSInd =
    :: ~SrcDule -> SemSInd
    struct
    end
end
  ToolSDule = SLink_on_LDule | ToolSDule
  SInd_on_LDule = load SInd with 
    {{ToolSDule; SrcDule; Trans}}
end | SInd_on_LDule

Lo_progtest14 =  
link
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList = struct type t = {} value nil = {} end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
      value de_cat : ~c:t ->
	       [`PP CatIList.t
               |`BB]
    end
  module ind CatIList = load IList with {{Value = Cat}}
  and Cat = 
    struct
      type t = 
	ind t: [`PP CatIList.t
               |`BB]
      value de_cat = fun ~c -> c . de
    end
  spec SrcDule =
  ~Cat -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
    end
  module SrcDule =
    struct
      value unPP = fun ~c ->
	match Cat.de_cat ~c with
	[`PP lc -> lc
	|`BB -> CatIList.nil]
    end
  library SLink =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec SrcDule =   ~Cat -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
    end
  spec ToolSDule = 
    sig
    end
  ToolSDule = 
    :: ~SrcDule  -> ToolSDule
    struct
    end
end
  SLink_on_LDule = load SLink with 
    {{SrcDule}}
  library SInd =
link
  spec IList = 
  ~Index ~Value ->
    sig
      type t
   end
  spec rec CatIList = IList with {{Value = Cat}}
  and Cat =
  ~Index ->
    sig
      type t
    end
  spec SrcDule = ~Cat -> 
    sig
      value unPP : ~c:Cat.t -> CatIList.t
    end
  spec SemSInd =
    sig
    end
  SemSInd =
    :: ~SrcDule -> SemSInd
    struct
    end
end
  ToolSDule = SLink_on_LDule | ToolSDule
  SInd_on_LDule = load SInd with 
    {{ToolSDule; SrcDule}}
end | ToolSDule

Lo_prog110 =  
link
  spec Bool =
    sig
      value true_ : [`True|`False]
      value false_ : [`True|`False]
      value not_ : ~it:[`True|`False] -> [`True|`False] 
      value and_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
      value or_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
    end
  Bool = 
    struct
      value true_ = `True
      value false_ = `False
      value not_ = [`True -> `False
                   |`False -> `True]
      value and_ = [`True fun ~b ~it -> b
                   |`False fun ~b ~it -> `False]
      value or_ = [`True fun ~b ~it -> `True
                  |`False fun ~b ~it -> b]
    end
  spec Char =
    sig 
      type t
      value char : ~c:t -> [`a|`b|`c
                           |`A|`B|`C
                           |`quote]
      value c_a : t
      value c_b : t
      value c_c : t
      value c_A : t
      value c_B : t
      value c_C : t
      value c_quote : t
      value upper : ~it:t -> t
      value lower : ~it:t -> t
      value eq : ~c:t ~it:t -> [`True|`False]
    end
  Char =
    struct
      type t = [`a|`b|`c
               |`A|`B|`C
               |`quote]
      value char = fun ~c -> c
      value c_a = `a
      value c_b = `b
      value c_c = `c
      value c_A = `A
      value c_B = `B
      value c_C = `C
      value c_quote = `quote
      value upper = [`a -> `A|`b -> `B|`c -> `C
                    |`A -> `A|`B -> `B|`C -> `C
		    |`quote -> `quote]
      value lower = [`a -> `a|`b -> `b|`c -> `c
                    |`A -> `a|`B -> `b|`C -> `c
		    |`quote -> `quote]
      value eq = 
	let true_ = `True
            false_ = `False 
	in
        [`a fun ~c ~it -> match c with 
          [`a -> true_|_ -> false_]
        |`b fun ~c ~it -> match c with 
          [`b -> true_|_ -> false_]
        |`c fun ~c ~it -> match c with 
          [`a -> false_|`b -> false_|`c -> true_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`A fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> true_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`B fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> true_|`C -> false_
	  |`quote -> false_]
        |`C fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> true_
	  |`quote -> false_]
        |`quote fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> true_]
        ] 
    end
  spec Elem = sig type t end
  spec List = 
  ~Elem ->
    sig
      type t
      value list : ~l:t ->
        ind list: [`Nil|`Cons {head: Elem.t; tail: list}]
      value de_list : ~l:t -> [`Nil|`Cons {head: Elem.t; tail: t}]
      value nil : t
      value cons : ~head:Elem.t ~tail:t -> t
    end
  library List =
    struct
      type t = ind list: [`Nil|`Cons {head: Elem.t; tail: list}]
      value list = fun ~l -> l
      value de_list = fun ~l -> l . de
      value nil = `Nil . con
      value cons = fun ~head ~tail -> {head; tail} .`Cons . con
    end
  spec EndoList = 
  ~List ->
    sig
      value foldr : ~init:List.t 
                    ~f: ~e:Elem.t ~r:List.t -> List.t 
                    ~l:List.t 
		      -> List.t
      value mapt : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value append : ~l:List.t ~k:List.t -> List.t 
      value is_nil : ~l:List.t -> [`True|`False]
    end
  library EndoList =
    struct
      value foldr = 
        fun ~init ~f ~l -> 
          match List.list ~l with
          fold [`Nil -> init
                |`Cons ht -> f ~e:ht.head ~r:ht.tail]
      value mapt = 
        fun ~f ~l -> 
	  match List.list ~l with
          fold [`Nil -> List.nil
                |`Cons ht -> List.cons ~head:(f ~e:ht.head) ~tail:ht.tail]
      value append = 
        fun ~l ~k ->
          match List.list ~l with
          fold [`Nil -> k
                |`Cons ht -> List.cons ~head:ht.head ~tail:ht.tail]
      value is_nil = fun ~l -> 
        match List.de_list ~l with
	[`Nil -> `True
 	|`Cons -> `False]
    end
  spec CharList = List with {Elem = Char}
  CharList = load List with {Elem = Char}
  spec CharEndoList = EndoList with {Elem = Char; List = CharList}
  CharEndoList = load EndoList with {Elem = Char; List = CharList}
  spec String =
  ~CharEndoList ->
    sig
      value eq : ~l:CharList.t ~k:CharList.t -> [`True|`False]
      value up : CharList.t
      value it : CharList.t
      value a : Char.t
      value prefix_by_a : ~tail:CharList.t -> CharList.t
      value shout : ~l:CharList.t -> CharList.t
    end
  String = 
    :: ~Bool -> String
    struct
      value eq =
        let non_nil_eq = fun ~it:ht -> fun ~l -> 
          match CharList.de_list ~l with
	  [`Nil -> Bool.false_
 	  |`Cons kht ->
 	     let head_matches = Char.eq ~c:ht.head ~it:kht.head
		 tail_equal = ht.tail ~l:kht.tail in
             Bool.and_ ~b:head_matches ~it:tail_equal]
	in
	fun ~l ~k -> 
          (match CharList.list ~l with
           fold [`Nil -> CharEndoList.is_nil
                |`Cons non_nil_eq])
	    ~l:k
      value up = CharList.cons ~head:Char.c_a 
                   ~tail:(CharList.cons ~head:Char.c_b
			    ~tail:CharList.nil)
      value it = CharList.cons ~head:Char.c_c 
                   ~tail:(CharList.cons ~head:Char.c_a 
                            ~tail:(CharList.cons ~head:Char.c_b
				     ~tail:CharList.nil))
      value a = Char.c_a
      value prefix_by_a = fun ~tail -> 
        CharList.cons ~head:Char.c_a ~tail
      value shout = fun ~l -> 
        CharEndoList.mapt ~l ~f:fun ~e -> Char.upper ~it:e  
    end
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value up : t
      value it : t
      value atj : t
      value prim : ~i:t -> t
    end
  Index =
    :: ~String -> Index
    struct
      type t = CharList.t
      value eq = fun ~i ~j -> String.eq ~l:i ~k:j
      value up = String.up
      value it = String.it
      value atj = String.up
      value prim = fun ~i -> 
        CharEndoList.append ~l:i 
          ~k:(CharList.cons ~head:Char.c_quote 
                ~tail:CharList.nil)
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value find_first : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
   end
  spec IElem = 
  ~Index ~Value -> 
    sig
      type t
      value i : ~e:t -> Index.t
      value v : ~e:t -> Value.t
      value assoc : ~i:Index.t ~v:Value.t -> t
      value imatch : ~e:t ~i:Index.t -> [`OK Value.t |`Error]
    end
  library IElem = 
    struct
      type t = {i: Index.t; v: Value.t}
      value i = fun ~e -> e.i
      value v = fun ~e -> e.v
      value assoc = fun ~i ~v -> {i; v}
      value imatch = fun ~e ~i -> 
        match Index.eq ~i ~j:(e.i) with
	[`True -> e.v .`OK
        |`False -> `Error] 
    end
  spec IElemList = List with {Elem = IElem}
  library IList = 
    :: ~IElemList -> IList
    struct
      type t = IElemList.t
      value nil = IElemList.nil
      value cons = fun ~i ~v ~l -> 
        IElemList.cons ~tail:l ~head:(IElem.assoc ~i ~v)
      value find = fun ~i ~l -> 
	let tail_or_in_head = fun ~it:ht ->
	  match ht.tail with
	  [`OK -> ht.tail
          |`Error -> IElem.imatch ~e:ht.head ~i]
	in
	match IElemList.list ~l with
        fold [`Nil -> `Error
             |`Cons tail_or_in_head]
      value find_first = fun ~i ~l ->
	let in_head_or_tail = fun ~ht ->
	  let head = IElem.imatch ~e:ht.head ~i in
          match head with
	  [`OK -> head
          |`Error -> ht.tail]
	in
	match IElemList.list ~l with
        fold [`Nil -> `Error
             |`Cons it -> in_head_or_tail ~ht:it]
    end
  spec Value' = Value
  spec IList' = IList with {Value = Value'; Index}
  spec Map2IList = 
  ~IElemList ~IList' ->
    sig
      value bmap : ~f: ~i:Index.t ~v:Value.t -> Value'.t 
	           ~l:IElemList.t ->
		     IList'.t 
    end
  library Map2IList =
    struct
      value bmap = fun ~f ~l -> 
	let consf = fun ~it:ht -> 
	  let i = IElem.i ~e:ht.head
	      v = IElem.v ~e:ht.head in
          IList'.cons ~i ~v:(f ~i ~v) ~l:ht.tail in
	match IElemList.list ~l with
        fold [`Nil -> IList'.nil
              |`Cons consf]
    end
  spec LCat =
  ~Index ->
    sig
      type cat
      type c_ilist
      value cat : ~c:cat -> 
        ind cat: [`PP ind lc: [`Nil
	                       |`Cons {head: {i: Index.t; v: cat};
					tail: lc}]
                 |`BB]
      value c_ilist : ~l:c_ilist -> 
	ind lc: [`Nil
                |`Cons {head: {i: Index.t; v: cat};
			 tail: lc}]
      value c_PP : ~lc:c_ilist -> cat
      value c_BB : cat
      value de_cat : ~c:cat -> 
        [`PP c_ilist
        |`BB]
      value de_list : ~l:c_ilist -> 
	[`Nil
	|`Cons {head: {i: Index.t; v: cat};
		 tail: c_ilist}]
      value nil : c_ilist
      value cons : ~head:{i: Index.t; v: cat} ~tail:c_ilist -> c_ilist
    end
  LCat = 
    struct
      type cat = 
        ind cat: [`PP ind lc: [`Nil
                             |`Cons {head: {i: Index.t; v: cat};
				      tail: lc}]
                 |`BB]
      type c_ilist = ind lc: [`Nil
                             |`Cons {head: {i: Index.t; v: ind cat: [`PP ind lc: [`Nil
                             |`Cons {head: {i: Index.t; v: cat};
				      tail: lc}]|`BB]};
				      tail: lc}]
      value cat = fun ~c -> c
      value c_ilist = fun ~l -> l
      value c_PP = fun ~lc -> lc .`PP . con
      value c_BB = `BB . con
      value de_cat = fun ~c -> c . de
      value de_list = fun ~l -> l . de
      value nil = `Nil . con
      value cons = fun ~head ~tail -> {head; tail} .`Cons . con
    end
  spec LFunct =
  ~LCat ->
    sig
      type funct
      type f_ilist
      value funct : ~f:funct -> 
        ind funct: [`F_ID LCat.cat
	           |`F_COMP {f1: funct; f2: funct}
		   |`F_PR {la: LCat.c_ilist; i: Index.t}
		   |`F_RECORD {a: LCat.cat; lf:
	  ind lf: [`Nil|`Cons {head: {i: Index.t; v: funct}; tail: lf}]}
		   |`F_pp {a: LCat.cat; lf:
	  ind lf: [`Nil|`Cons {head: {i: Index.t; v: funct}; tail: lf}]}
		   |`F_ss {a: LCat.cat; lf:
	  ind lf: [`Nil|`Cons {head: {i: Index.t; v: funct}; tail: lf}]}
		   |`F_ee {lf:
	  ind lf: [`Nil|`Cons {head: {i: Index.t; v: funct}; tail: lf}];
		            i: Index.t; f: funct}
		   |`F_ii funct
		   |`F_tt funct]
      value f_ilist : ~l:f_ilist -> 
	ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]
      value f_ID : ~c:LCat.cat -> funct
      value de_list : ~l:f_ilist -> 
	[`Nil|
	 `Cons {head: {i: Index.t; v: funct};
		 tail: f_ilist}]
      value de_funct : ~f:funct -> 
        [`F_ID LCat.cat
	|`F_COMP {f1: funct; f2: funct}
	|`F_PR {la: LCat.c_ilist; i: Index.t}
	|`F_RECORD {a: LCat.cat; lf: f_ilist}
	|`F_pp {a: LCat.cat; lf: f_ilist}
	|`F_ss {a: LCat.cat; lf: f_ilist}
	|`F_ee {lf: f_ilist; i: Index.t; f: funct}
	|`F_ii funct
	|`F_tt funct]
      value nil : f_ilist
      value cons : ~head:{i: Index.t; v: funct} ~tail:f_ilist -> f_ilist
    end
  LFunct = 
    struct
      type funct = 
        ind funct: [`F_ID LCat.cat
	           |`F_COMP {f1: funct; f2: funct}
		   |`F_PR {la: LCat.c_ilist; i: Index.t}
		   |`F_RECORD {a: LCat.cat; lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]}
		   |`F_pp {a: LCat.cat; lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]}
		   |`F_ss {a: LCat.cat; lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]}
		   |`F_ee {lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]; i: Index.t; f: funct}
		   |`F_ii funct
		   |`F_tt funct]
      type f_ilist = 
	ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: ind funct: [`F_ID LCat.cat
	           |`F_COMP {f1: funct; f2: funct}
		   |`F_PR {la: LCat.c_ilist; i: Index.t}
		   |`F_RECORD {a: LCat.cat; lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]}
		   |`F_pp {a: LCat.cat; lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]}
		   |`F_ss {a: LCat.cat; lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]}
		   |`F_ee {lf: ind lf: [`Nil
                |`Cons {head: {i: Index.t; v: funct};
			 tail: lf}]; i: Index.t; f: funct}
		   |`F_ii funct
		   |`F_tt funct]};
			 tail: lf}]
      value funct = fun ~f -> f
      value f_ilist = fun ~l -> l
      value f_ID = fun ~c -> c .`F_ID . con
      value de_list = fun ~l -> l . de
      value de_funct = fun ~f -> f . de
      value nil = `Nil . con
      value cons = fun ~head ~tail -> {head; tail} .`Cons . con
    end
  spec LTrans =
  ~LFunct ->
    sig
      type trans
      type t_ilist
    end
  LTrans = 
    struct
      type trans = 
        ind trans: [`T_ID LCat.cat
	           |`T_COMP {t1: trans; t2: trans}
		   |`T_id LFunct.funct
	           |`T_comp {t1: trans; t2: trans}] 
      type t_ilist = 
	ind lt: [`Nil
                |`Cons {head: {i: Index.t; v: ind trans: [`T_ID LCat.cat
	           |`T_COMP {t1: trans; t2: trans}
		   |`T_id LFunct.funct
	           |`T_comp {t1: trans; t2: trans}]};
			 tail: lt}]
    end
  spec LCatValue = ~LCat -> Value
  library LCatValue = 
    struct
      type t = LCat.cat
    end
  spec LCatIElem = IElem with {Value = load LCatValue; Index}
  library LCatIElem = load IElem with {Value = load LCatValue; Index}
  spec LCatList = List with {Elem = load LCatIElem}
  spec SrcLDule =
  ~LFunct -> 
    sig
      value src : ~f:LFunct.funct -> [`OK LCat.cat|`Error]
      value trg : ~f:LFunct.funct -> [`OK LCat.cat|`Error]
    end
  SrcLDule =
    struct
      value src =
	fun ~f ->
	  match LFunct.funct ~f with
	  fold [`F_ID b -> b .`OK
 	        |`F_COMP f1xf2 -> f1xf2.f1
		|`F_PR laxi -> (LCat.c_PP ~lc:laxi.la) .`OK
		|`F_RECORD axlf -> axlf.a .`OK
		|`F_pp axlf -> axlf.a .`OK
		|`F_ss axlf -> axlf.a .`OK
		|`F_ee lfxixf -> lfxixf.f
		|`F_ii c -> c 
		|`F_tt c -> c]
      value trg = fun ~f ->
	match LFunct.funct ~f with
	fold [`F_ID b -> b .`OK
 	      |`F_COMP f1xf2 -> f1xf2.f2
	      |`F_PR laxi -> LCat.c_BB .`OK 
	      |`F_RECORD axlf -> LCat.c_BB .`OK
	      |`F_pp -> LCat.c_BB .`OK
	      |`F_ss -> LCat.c_BB .`OK
	      |`F_ee -> LCat.c_BB .`OK
	      |`F_ii -> LCat.c_BB .`OK
	      |`F_tt -> LCat.c_BB .`OK]
    end
end | SrcLDule

Lo_prog111 =  
link
  spec Bool =
    sig
      value true_ : [`True|`False]
      value false_ : [`True|`False]
      value not_ : ~it:[`True|`False] -> [`True|`False] 
      value and_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
      value or_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
    end
  Bool = 
    struct
      value true_ = `True
      value false_ = `False
      value not_ = [`True -> `False
                   |`False -> `True]
      value and_ = [`True fun ~b ~it -> b
                   |`False fun ~b ~it -> `False]
      value or_ = [`True fun ~b ~it -> `True
                  |`False fun ~b ~it -> b]
    end
  spec Char =
    sig 
      type t
      value de_char : ~c:t -> [`a|`b|`c
                              |`A|`B|`C
                              |`quote]
      value c_a : t
      value c_b : t
      value c_c : t
      value c_A : t
      value c_B : t
      value c_C : t
      value c_quote : t
      value upper : ~it:t -> t
      value lower : ~it:t -> t
      value eq : ~c:t ~it:t -> [`True|`False]
    end
  Char =
    struct
      type t = [`a|`b|`c
               |`A|`B|`C
               |`quote]
      value de_char = fun ~c -> c
      value c_a = `a
      value c_b = `b
      value c_c = `c
      value c_A = `A
      value c_B = `B
      value c_C = `C
      value c_quote = `quote
      value upper = fun ~it -> match it with
                    [`a -> `A|`b -> `B|`c -> `C
                    |`A -> `A|`B -> `B|`C -> `C
		    |_ -> it]
      value lower = [`a -> `a|`b -> `b|`c -> `c
                    |`A -> `a|`B -> `b|`C -> `c
		    |`quote -> `quote]
      value eq = 
	let true_ = `True
	    false_ = `False 
	in
        [`a fun ~c ~it -> match c with 
          [`a -> true_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`b fun ~c ~it -> match c with 
          [`a -> false_|`b -> true_|`c -> false_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`c fun ~c ~it -> match c with 
          [`a -> false_|`b -> false_|`c -> true_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`A fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> true_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`B fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> true_|`C -> false_
	  |`quote -> false_]
        |`C fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> true_
	  |`quote -> false_]
        |`quote fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> true_]
        ] 
    end
  spec Elem = sig type t end
  spec List = 
  ~Elem ->
    sig
      type t
      value ind_list : ~l:t ->
        ind t: [`Nil|`Cons {head : Elem.t; tail : t}]
      value de_list : ~l:t -> [`Nil|`Cons {head : Elem.t; tail : t}]
      value nil : t
      value cons : ~head:Elem.t ~tail:t -> t
    end
  library List =
    struct
      type t = ind t: [`Nil|`Cons {head : Elem.t; tail : t}]
      value ind_list = fun ~l -> l
      value de_list = fun ~l -> l . de
      value nil = `Nil . con
      value cons = fun ~head ~tail -> {head; tail} .`Cons . con
    end
  spec EndoList = 
  ~List ->
    sig
      value foldr : ~init:List.t 
                    ~f: ~e:Elem.t ~r:List.t -> List.t 
                    ~l:List.t 
		      -> List.t
      value mapt : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value append : ~l:List.t ~k:List.t -> List.t 
      value is_nil : ~l:List.t -> [`True|`False]
    end
  library EndoList =
    struct
      value foldr = 
        fun ~init ~f ~l -> 
          match List.ind_list ~l with
          fold [`Nil -> init
                |`Cons ht -> f ~e:ht.head ~r:ht.tail]
      value mapt = fun ~f ~l -> 
	match List.ind_list ~l with
        fold [`Nil -> List.nil
              |`Cons ht -> List.cons ~head:(f ~e:ht.head) ~tail:ht.tail]
      value append = fun ~l ~k ->
        match List.ind_list ~l with
        fold [`Nil -> k
              |`Cons ht -> List.cons ~head:ht.head ~tail:ht.tail]
      value is_nil = fun ~l -> 
        match List.de_list ~l with
	[`Nil -> `True
 	|`Cons -> `False]
    end
  spec CharList = List with {Elem = Char}
  CharList = load List with {Elem = Char}
  library ArgChar = {Elem = Char; List = CharList}
  spec CharEndoList = EndoList with load ArgChar
  CharEndoList = load EndoList with load ArgChar
  spec String =
  ~CharEndoList ->
    sig
      value eq : ~l:CharList.t ~k:CharList.t -> [`True|`False]
      value up : CharList.t
      value it : CharList.t
      value a : Char.t
      value prefix_by_a : ~tail:CharList.t -> CharList.t
      value shout : ~l:CharList.t -> CharList.t
    end
  module String = 
    :: ~Bool -> String
    struct
      value eq =
        let non_nil_eq = fun ~it:ht -> fun ~l -> 
          match CharList.de_list ~l with
	  [`Nil -> Bool.false_
 	  |`Cons kht ->
 	     let head_matches = Char.eq ~c:ht.head ~it:kht.head
		 tail_equal = ht.tail ~l:kht.tail in
             Bool.and_ ~b:head_matches ~it:tail_equal]
	in
	fun ~l ~k -> 
          (match CharList.ind_list ~l with
           fold [`Nil -> CharEndoList.is_nil
                |`Cons non_nil_eq]) 
	    ~l:k
      value up = CharList.cons ~head:Char.c_a 
                   ~tail:(CharList.cons ~head:Char.c_b
			    ~tail:CharList.nil)
      value it = CharList.cons ~head:Char.c_c 
                   ~tail:(CharList.cons ~head:Char.c_a 
                            ~tail:(CharList.cons ~head:Char.c_b
				     ~tail:CharList.nil))
      value a = Char.c_a
      value prefix_by_a = fun ~tail -> 
        CharList.cons ~head:Char.c_a ~tail
      value shout = fun ~l -> 
        CharEndoList.mapt ~l ~f:fun ~e -> Char.upper ~it:e  
    end
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value find_first : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
   end
  library IList =
    link
      spec IElem = 
      ~Index ~Value -> 
        sig
	  type t
	  value i : ~e:t -> Index.t
          value v : ~e:t -> Value.t
          value assoc : ~i:Index.t ~v:Value.t -> t
          value imatch : ~e:t ~i:Index.t -> [`OK Value.t |`Error]
        end
      IElem = 
	struct
	  type t = {i : Index.t; v : Value.t}
          value i = fun ~e -> e.i
          value v = fun ~e -> e.v
          value assoc = fun ~i ~v -> {i; v}
          value imatch = fun ~e ~i -> 
            match Index.eq ~i ~j:e.i with
	    [`True -> e.v .`OK
            |`False -> `Error] 
	end
      spec IElemList = List with {Elem = IElem}
      IElemList = load List with {Elem = IElem}
      IList2 = 
        :: ~IElemList -> IList
	struct
	  type t = IElemList.t
  	  value nil = IElemList.nil
          value cons = fun ~i ~v ~l -> 
            IElemList.cons ~tail:l ~head:(IElem.assoc ~i ~v)
          value find = fun ~i ~l -> 
	    let tail_or_in_head = fun ~it:ht ->
	      match ht.tail with
	      [`OK -> ht.tail
              |`Error -> IElem.imatch ~e:ht.head ~i]
	    in
	    match IElemList.ind_list ~l with
            fold [`Nil -> `Error
                  |`Cons tail_or_in_head]
          value find_first = fun ~i ~l ->
	    let in_head_or_tail = fun ~it:ht ->
	      let head = IElem.imatch ~e:ht.head ~i in
              match head with
	      [`OK -> head
              |`Error -> ht.tail]
	    in
	    match IElemList.ind_list ~l with
            fold [`Nil -> `Error
                  |`Cons in_head_or_tail]
	end
    end :> ~Value -> {IList2 : IList} . IList2
  spec rec PCatIList = IList with {Index; Value = PCat}
  and PCat =
    sig
      type t
      value ind_cat : ~c:t -> 
	ind t: [`PP PCatIList.t
               |`BB]
      value de_cat : ~c:t ->
	       [`PP PCatIList.t
               |`BB]
      value c_PP : ~lc:PCatIList.t -> t
      value c_BB : t
      value unPP : ~c:t -> [`OK PCatIList.t|`Error]
    end
  spec rec PFunctIList = IList with {Value = PFunct; Index}
  and PFunct =
  ~PCat ->
    sig
      type t
      value ind_funct : ~f:t -> 
        ind t: [`F_ID PCat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {la : PCatIList.t; i : Index.t}
	       |`F_RECORD {a : PCat.t; lf : PFunctIList.t}
	       |`F_pp {a : PCat.t; lf : PFunctIList.t}]
      value de_funct : ~f:t ->
               [`F_ID PCat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {la : PCatIList.t; i : Index.t}
	       |`F_RECORD {a : PCat.t; lf : PFunctIList.t}
	       |`F_pp {a : PCat.t; lf : PFunctIList.t}]
      value f_ID : ~b:PCat.t -> t
      value f_COMP : ~f1:t ~f2:t -> t
      value f_PR : ~la:PCatIList.t ~i:Index.t -> t
      value f_RECORD : ~a:PCat.t ~lf:PFunctIList.t -> t
      value f_pp : ~a:PCat.t ~lf:PFunctIList.t -> t
    end
  spec rec PTransIList = IList with {Value = PTrans; Index}
  and PTrans =
  ~PFunct ->
    sig
      type t
      value t_ID : ~b:PCat.t -> t
      value t_COMP : ~t1:t ~t2:t -> t
      value t_PR : ~la:PCatIList.t ~i:Index.t -> t
      value t_RECORD : ~a:PCat.t ~lt:PTransIList.t -> t
      value t_pp : ~a:PCat.t ~lt:PTransIList.t -> t
      value t_id : ~g:PFunct.t -> t
      value t_comp : ~t1:t ~t2:t -> t
      value t_pr : ~lf:PFunctIList.t ~i:Index.t -> t
      value t_record : ~f:PFunct.t ~lt:PTransIList.t -> t
    end
  spec SrcPDule =
  ~PFunct -> 
    sig
      value src : ~f:PFunct.t -> [`OK PCat.t|`Error]
      value trg : ~f:PFunct.t -> [`OK PCat.t|`Error]
    end
  spec rec SSignIList = IList with {Index; Value = SSign}
  and SSign =
  ~PFunctIList ->
    sig
      type t
      value ind_sign : ~s:t -> 
        ind t: [`S_Pp SSignIList.t
	       |`S_Bb {lc : PCatIList.t; lf : PFunctIList.t}
	       |`S_Ww {m1 : SDule.t; s2 : t}]
      value de_sign : ~s:t ->
	       [`S_Pp SSignIList.t
	       |`S_Bb {lc : PCatIList.t; lf : PFunctIList.t}
	       |`S_Ww {m1 : SDule.t; s2 : t}]
      value s_Pp : ~ls:SSignIList.t -> t
      value s_Bb : ~lc:PCatIList.t ~lf:PFunctIList.t -> t
      value s_Ww : ~m1:SDule.t ~s2:t -> t
    end
  and SDuleIList = IList with {Value = SDule; Index}
  and SDule =
  ~PTransIList ->
    sig
      type t
      value ind_dule : ~m:t -> 
        ind t: [`M_Id SSign.t
	       |`M_Comp {m1 : t; m2 : t}
	       |`M_Pr {lr : SSignIList.t; i : Index.t}
	       |`M_Record {r : SSign.t; lm : SDuleIList.t}
	       |`M_Base {r : SSign.t; s : SSign.t; 
			 lg : PFunctIList.t; lt : PTransIList.t}
	       |`M_Inst {m1 : t; m2 : t}
	       |`M_Cut {m1 : t; r2 : SSign.t}
	       |`M_Join {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Link {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Ind {lr : SSignIList.t; lm : SDuleIList.t}]
      value dule : ~m:t ->
               [`M_Id SSign.t
	       |`M_Comp {m1 : t; m2 : t}
	       |`M_Pr {lr : SSignIList.t; i : Index.t}
	       |`M_Record {r : SSign.t; lm : SDuleIList.t}
	       |`M_Base {r : SSign.t; s : SSign.t; 
			 lg : PFunctIList.t; lt : PTransIList.t}
	       |`M_Inst {m1 : t; m2 : t}
	       |`M_Cut {m1 : t; r2 : SSign.t}
	       |`M_Join {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Link {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Ind {lr : SSignIList.t; lm : SDuleIList.t}]
    end
  module ind SSignIList = load IList with {Index; Value = SSign}
  and SSign = 
    struct
      type t = 
	ind t: [`S_Pp SSignIList.t
	       |`S_Bb {lc : PCatIList.t; lf : PFunctIList.t}
	       |`S_Ww {m1 : SDule.t; s2 : t}]
      value ind_sign = fun ~s -> s
      value de_sign = fun ~s -> s . de
      value s_Pp = fun ~ls -> ls . `S_Pp . con
      value s_Bb = fun ~lc ~lf -> {lc; lf} . `S_Bb . con
      value s_Ww = fun ~m1 ~s2 -> {m1; s2} . `S_Ww . con
    end
  and SDuleIList = load IList with {Value = SDule; Index}
  and SDule = 
    struct
      type t = 
        ind t: [`M_Id SSign.t
	       |`M_Comp {m1 : t; m2 : t}
	       |`M_Pr {lr : SSignIList.t; i : Index.t}
	       |`M_Record {r : SSign.t; lm : SDuleIList.t}
	       |`M_Base {r : SSign.t; s : SSign.t; 
			 lg : PFunctIList.t; lt : PTransIList.t}
	       |`M_Inst {m1 : t; m2 : t}
	       |`M_Cut {m1 : t; r2 : SSign.t}
	       |`M_Join {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Link {lr : SSignIList.t; lm : SDuleIList.t}
	       |`M_Ind {lr : SSignIList.t; lm : SDuleIList.t}]
      value ind_dule = fun ~m -> m
      value dule = fun ~m -> m . de
    end
end :> {}

Lo_prog112 =  
link
  spec Bool =
    sig
      value true_ : [`True|`False]
      value false_ : [`True|`False]
      value not_ : ~it:[`True|`False] -> [`True|`False] 
      value and_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
      value or_ : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
    end
  Bool = 
    struct
      value true_ = `True
      value false_ = `False
      value not_ = [`True -> `False
                   |`False -> `True]
      value and_ = [`True fun ~b ~it -> b
                   |`False fun ~b ~it -> `False]
      value or_ = [`True fun ~b ~it -> `True
                  |`False fun ~b ~it -> b]
    end
  spec Char =
    sig 
      type t
      value de_char : ~c:t -> [`a|`b|`c
                              |`A|`B|`C
                              |`quote]
      value c_a : t
      value c_b : t
      value c_c : t
      value c_A : t
      value c_B : t
      value c_C : t
      value c_quote : t
      value upper : ~it:t -> t
      value lower : ~it:t -> t
      value eq : ~c:t ~it:t -> [`True|`False]
    end
  Char =
    struct
      type t = [`a|`b|`c
               |`A|`B|`C
               |`quote]
      value de_char = fun ~c -> c
      value c_a = `a
      value c_b = `b
      value c_c = `c
      value c_A = `A
      value c_B = `B
      value c_C = `C
      value c_quote = `quote
      value upper = [`a -> `A|`b -> `B|`c -> `C
                    |`A -> `A|`B -> `B|`C -> `C
		    |`quote -> `quote]
      value lower = [`a -> `a|`b -> `b|`c -> `c
                    |`A -> `a|`B -> `b|`C -> `c
		    |`quote -> `quote]
      value eq = 
	let true_ = `True
	    false_ = `False 
	in
        [`a fun ~c ~it -> match c with 
          [`a -> true_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`b fun ~c ~it -> match c with 
          [`a -> false_|`b -> true_|`c -> false_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`c fun ~c ~it -> match c with 
          [`a -> false_|`b -> false_|`c -> true_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`A fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> true_|`B -> false_|`C -> false_
	  |`quote -> false_]
        |`B fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> true_|`C -> false_
	  |`quote -> false_]
        |`C fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> true_
	  |`quote -> false_]
        |`quote fun ~c ~it -> match c with
          [`a -> false_|`b -> false_|`c -> false_
          |`A -> false_|`B -> false_|`C -> false_
	  |`quote -> true_]
        ] 
    end
  spec Elem = sig type t end
  spec List = 
  ~Elem ->
    sig
      type t
      value ind_list : ~l:t ->
        ind t: [`Nil|`Cons {head : Elem.t; tail : t}]
      value de_list : ~l:t -> [`Nil|`Cons {head : Elem.t; tail : t}]
      value nil : t
      value cons : ~head:Elem.t ~tail:t -> t
    end
  library List =
    struct
      type t = ind t: [`Nil|`Cons {head : Elem.t; tail : t}]
      value ind_list = fun ~l -> l
      value de_list = fun ~l -> l . de
      value nil = `Nil . con
      value cons = fun ~head ~tail -> {head; tail} .`Cons . con
    end
  spec EndoList = 
  ~List ->
    sig
      value foldr : ~init:List.t 
                    ~f: ~e:Elem.t ~r:List.t -> List.t 
                    ~l:List.t 
		      -> List.t
      value mapt : ~f: ~e:Elem.t -> Elem.t ~l:List.t -> List.t 
      value append : ~l:List.t ~k:List.t -> List.t 
      value is_nil : ~l:List.t -> [`True|`False]
    end
  library EndoList =
    struct
      value foldr = 
        fun ~init ~f ~l -> 
          match List.ind_list ~l with
          fold [`Nil -> init
                |`Cons ht -> f ~e:ht.head ~r:ht.tail]
      value mapt = fun ~f ~l -> 
	match List.ind_list ~l with
        fold [`Nil -> List.nil
              |`Cons ht -> List.cons ~head:(f ~e:ht.head) ~tail:ht.tail]
      value append = fun ~l ~k ->
        match List.ind_list ~l with
        fold [`Nil -> k
              |`Cons ht -> List.cons ~head:ht.head ~tail:ht.tail]
      value is_nil = fun ~l -> 
        match List.de_list ~l with
	[`Nil -> `True
 	|`Cons -> `False]
    end
  spec CharList = List with {Elem = Char}
  CharList = load List with {Elem = Char}
  library ArgChar = {Elem = Char; List = CharList}
  spec CharEndoList = EndoList with load ArgChar
  CharEndoList = load EndoList with load ArgChar
  spec String =
  ~CharEndoList ->
    sig
      value eq : ~l:CharList.t ~k:CharList.t -> [`True|`False]
      value up : CharList.t
      value it : CharList.t
      value a : Char.t
      value prefix_by_a : ~tail:CharList.t -> CharList.t
      value shout : ~l:CharList.t -> CharList.t
    end
  module String = 
    :: ~Bool -> String
    struct
      value eq =
        let non_nil_eq = fun ~it:ht -> fun ~l -> 
          match CharList.de_list ~l with
	  [`Nil -> Bool.false_
 	  |`Cons kht ->
 	     let head_matches = Char.eq ~c:ht.head ~it:kht.head
		 tail_equal = ht.tail ~l:kht.tail in
             Bool.and_ ~b:head_matches ~it:tail_equal]
	in
	fun ~l ~k -> 
          (match CharList.ind_list ~l with
           fold [`Nil -> CharEndoList.is_nil
                |`Cons non_nil_eq])
	    ~l:k
      value up = CharList.cons ~head:Char.c_a 
                   ~tail:(CharList.cons ~head:Char.c_b
			    ~tail:CharList.nil)
      value it = CharList.cons ~head:Char.c_c 
                   ~tail:(CharList.cons ~head:Char.c_a 
                            ~tail:(CharList.cons ~head:Char.c_b
				     ~tail:CharList.nil))
      value a = Char.c_a
      value prefix_by_a = fun ~tail -> 
        CharList.cons ~head:Char.c_a ~tail
      value shout = fun ~l -> 
        CharEndoList.mapt ~l ~f:fun ~e -> Char.upper ~it:e  
    end
  spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value up : t
      value it : t
      value atj : t
      value prim : ~i:t -> t
    end
  Index =
    :: ~String -> Index
    struct
      type t = CharList.t
      value eq = fun ~i ~j -> String.eq ~l:i ~k:j
      value up = String.up
      value it = String.it
      value atj = String.up
      value prim = fun ~i -> 
        CharEndoList.append ~l:i 
          ~k:(CharList.cons ~head:Char.c_quote 
                ~tail:CharList.nil)
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value find_first : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
   end
  library IList =
    link
      spec IElem = 
      ~Index ~Value -> 
        sig
	  type t
	  value i : ~e:t -> Index.t
          value v : ~e:t -> Value.t
          value assoc : ~i:Index.t ~v:Value.t -> t
          value imatch : ~e:t ~i:Index.t -> [`OK Value.t |`Error]
        end
      IElem = 
	struct
	  type t = {i : Index.t; v : Value.t}
          value i = fun ~e -> e.i
          value v = fun ~e -> e.v
          value assoc = fun ~i ~v -> {i; v}
          value imatch = fun ~e ~i -> 
            match Index.eq ~i ~j:e.i with
	    [`True -> e.v .`OK
            |`False -> `Error] 
	end
      spec IElemList = List with {Elem = IElem}
      IElemList = load List with {Elem = IElem}
      IList2 = 
        :: ~IElemList -> IList
	struct
	  type t = IElemList.t
  	  value nil = IElemList.nil
          value cons = fun ~i ~v ~l -> 
            IElemList.cons ~tail:l ~head:(IElem.assoc ~i ~v)
          value find = fun ~i ~l -> 
	    let tail_or_in_head = fun ~it:ht ->
	      match ht.tail with
	      [`OK -> ht.tail
              |`Error -> IElem.imatch ~e:ht.head ~i]
	    in
	    match IElemList.ind_list ~l with
            fold [`Nil -> `Error
                  |`Cons tail_or_in_head]
          value find_first = fun ~i ~l ->
	    let in_head_or_tail = fun ~it:ht ->
	      let head = IElem.imatch ~e:ht.head ~i in
              match head with
	      [`OK -> head
              |`Error -> ht.tail]
	    in
	    match IElemList.ind_list ~l with
            fold [`Nil -> `Error
                  |`Cons in_head_or_tail]
	end
    end | IList2
  spec rec LCatIList = IList with {Index; Value = LCat}
  and LCat =
    sig
      type t
      value ind_cat : ~c:t -> 
	ind t: [`PP LCatIList.t
               |`BB]
      value de_cat : ~c:t ->
	       [`PP LCatIList.t
               |`BB]
      value c_PP : ~lc:LCatIList.t -> t
      value c_BB : t
      value unPP : ~c:t -> [`OK LCatIList.t|`Error]
    end
  module ind LCatIList = load IList with {Index; Value = LCat}
  and LCat = 
    struct
      type t = 
	ind t: [`PP LCatIList.t
               |`BB]
      value ind_cat = fun ~c -> c
      value de_cat = fun ~c -> c . de
      value c_PP = fun ~lc -> lc .`PP . con
      value c_BB = `BB . con
      value unPP = fun ~c ->
	match c with
	fold [`PP lc -> lc .`OK
	      |`BB -> `Error ]
    end
  spec rec LFunctIList = IList with {Value = LFunct; Index}
  and LFunct =
  ~Index ~LCat ->
    sig
      type t
      value ind_funct : ~f:t -> 
        ind t: [`F_ID LCat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {la : LCatIList.t; i : Index.t}
	       |`F_RECORD {a : LCat.t; lf : LFunctIList.t}
	       |`F_pp {a : LCat.t; lf : LFunctIList.t}
	       |`F_ss {a : LCat.t; lf : LFunctIList.t}
	       |`F_ee {lf : LFunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value de_funct : ~f:t ->
               [`F_ID LCat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {la : LCatIList.t; i : Index.t}
	       |`F_RECORD {a : LCat.t; lf : LFunctIList.t}
	       |`F_pp {a : LCat.t; lf : LFunctIList.t}
	       |`F_ss {a : LCat.t; lf : LFunctIList.t}
	       |`F_ee {lf : LFunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value f_ID : ~c:LCat.t -> t
      value f_COMP : ~f1:t ~f2:t -> t
      value f_PR : ~la:LCatIList.t ~i:Index.t -> t
    end
  module ind LFunctIList = load IList with {Value = LFunct; Index}
  and LFunct = 
    struct
      type t = 
        ind t: [`F_ID LCat.t
	       |`F_COMP {f1 : t; f2 : t}
	       |`F_PR {la : LCatIList.t; i : Index.t}
	       |`F_RECORD {a : LCat.t; lf : LFunctIList.t}
	       |`F_pp {a : LCat.t; lf : LFunctIList.t}
	       |`F_ss {a : LCat.t; lf : LFunctIList.t}
	       |`F_ee {lf : LFunctIList.t; i : Index.t; f : t}
	       |`F_ii t
	       |`F_tt t]
      value ind_funct = fun ~f -> f
      value de_funct = fun ~f -> f . de
      value f_ID = fun ~c -> c .`F_ID . con
      value f_COMP = fun ~f1 ~f2 -> {f1; f2} .`F_COMP . con
      value f_PR = fun ~la ~i -> {la; i} .`F_PR . con
    end
  spec rec LTransIList = IList with {Value = LTrans; Index}
  and LTrans =
  ~LFunct ->
    sig
      type t
    end
  module ind LTransIList = load IList with {Value = LTrans; Index}
  and LTrans = 
    struct
      type t = 
        ind t: [`T_ID LCat.t
	       |`T_COMP {t1 : t; t2 : t}
	       |`T_PR {la : LCatIList.t; i : Index.t}
	       |`T_RECORD {a : LCat.t; lt : LTransIList.t}
	       |`T_pp {a : LCat.t; lt : LTransIList.t}
	       |`T_ss {a : LCat.t; lt : LTransIList.t}
	       |`T_ee {lt : LTransIList.t; i : Index.t; t : t}
	       |`T_ii t
	       |`T_tt t
	       |`T_id LFunct.t
	       |`T_comp {t1 : t; t2 : t} 
	       |`T_pr {lf : LFunctIList.t; i : Index.t}
	       |`T_record {f : LFunct.t; lt : LTransIList.t}
	       |`T_in {lf : LFunctIList.t; i : Index.t}
	       |`T_case {lt : LTransIList.t; h : LFunct.t}
	       |`TL_case {f : LFunct.t; lt : LTransIList.t; h : LFunct.t}
	       |`T_appl {lf : LFunctIList.t; i : Index.t; f : LFunct.t}
	       |`T_curry {i : Index.t; t : t}
	       |`TL_map {f : LFunct.t; t : t}
	       |`T_con LFunct.t
	       |`T_fold {f : LFunct.t; t : t}
	       |`TL_fold {f : LFunct.t; t : t}
	       |`TL_de LFunct.t
	       |`T_de LFunct.t
	       |`T_unfold {f : LFunct.t; t :t}
	       |`TL_unfold {f : LFunct.t; t :t}
	       |`TL_con LFunct.t
	       |`T_fix t
	       |`TL_fix t]
    end
  library LCatOkError = 
    :: ~LCat -> Value
    struct
      type t = [`OK LCat.t|`Error]
    end
  spec LCatOkErrorIList = IList with {Value = load LCatOkError; Index}
  LCatOkErrorIList = load IList with {Value = load LCatOkError; Index}
  spec OkMap = 
  ~LCatOkErrorIList ->
    sig
      value ok_map : ~l:LCatOkErrorIList.t -> LCatIList.t
    end
  spec SrcLDule =
  ~LFunct -> 
    sig
      value src : ~f:LFunct.t -> [`OK LCat.t|`Error]
      value trg : ~f:LFunct.t -> [`OK LCat.t|`Error]
      value trg' : ~f:LFunct.t -> [`OK LCat.t|`Error]
    end
  module SrcLDule =
    struct
      value src =
        let fiur = fun ~it:f ->
          match f with
          [`OK c -> match LCat.unPP ~c with
                   [`OK l -> LCatIList.find ~i:Index.atj ~l
                   |`Error e -> e .`Error]
          |`Error e -> e .`Error] in
	fun ~f ->
	  match LFunct.ind_funct ~f with
	  fold [`F_ID b -> b .`OK
 	        |`F_COMP f1xf2 -> f1xf2.f1
		|`F_PR laxi -> (LCat.c_PP ~lc:laxi.la) .`OK
		|`F_RECORD axlf -> axlf.a .`OK
		|`F_pp axlf -> axlf.a .`OK
		|`F_ss axlf -> axlf.a .`OK
		|`F_ee lfxixf -> lfxixf.f
		|`F_ii fiur
		|`F_tt fiur]
      value rec trg = fun ~f ->
	match LFunct.de_funct ~f with
	[`F_ID b -> b .`OK
 	|`F_COMP f1xf2 -> trg ~f:f1xf2.f2
	|`F_PR laxi -> LCatIList.find ~i:laxi.i ~l:laxi.la
	|`F_RECORD axlf -> axlf.a .`OK
	|`F_pp -> LCat.c_BB .`OK
	|`F_ss -> LCat.c_BB .`OK
	|`F_ee -> LCat.c_BB .`OK
	|`F_ii f -> trg ~f
	|`F_tt f -> trg ~f]
      value trg' = fun ~f ->
	match LFunct.ind_funct ~f with
	fold [`F_ID b -> b .`OK
 	      |`F_COMP f1xf2 -> f1xf2.f2
	      |`F_PR laxi -> LCatIList.find ~i:laxi.i ~l:laxi.la
	      |`F_RECORD axlf -> axlf.a .`OK
	      |`F_pp -> LCat.c_BB .`OK
	      |`F_ss -> LCat.c_BB .`OK
	      |`F_ee -> LCat.c_BB .`OK
	      |`F_ii f -> f
	      |`F_tt f -> f]
    end
end | {}

Lo_rec25 =  
link
  spec Index =
    sig
      type t
    end
  Index =
    struct
      type t = {}
    end
  spec Value = sig type t end
  spec IList = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList =
	struct
	  type t = {}
  	  value nil = {}
	end
  spec rec LCatIList = IList with {Value = LCat; Index}
  and LCat =
    sig
      type t
      value c_BB : t
    end
  module ind LCatIList = load IList with {Value = LCat; Index}
  and LCat = 
    struct
      type t = ind t: [`PP LCatIList.t
                      |`BB]
      value c_BB = `BB . con
    end
  spec rec LFunctIList = IList with {Value = LFunct; Index}
  and LFunct =
  ~LCat ->
    sig
      type t
      value funct : ~f:t -> 
        ind t: [`F_ID LCat.t
	       |`F_COMP {f1: t; f2: t}
	       |`F_PR {la: LCatIList.t; i: Index.t}
	       |`F_RECORD {a: LCat.t; lf: LFunctIList.t}
	       |`F_pp {a: LCat.t; lf: LFunctIList.t}
	       |`F_ss {a: LCat.t; lf: LFunctIList.t}
	       |`F_ee {lf: LFunctIList.t; i: Index.t; f: t}
	       |`F_ii t
	       |`F_tt t]
    end
  module ind LFunctIList = load IList with {Value = LFunct; Index}
  and LFunct = 
    struct
      type t = 
        ind t: [`F_ID LCat.t
	       |`F_COMP {f1: t; f2: t}
	       |`F_PR {la: LCatIList.t; i: Index.t}
	       |`F_RECORD {a: LCat.t; lf: LFunctIList.t}
	       |`F_pp {a: LCat.t; lf: LFunctIList.t}
	       |`F_ss {a: LCat.t; lf: LFunctIList.t}
	       |`F_ee {lf: LFunctIList.t; i: Index.t; f: t}
	       |`F_ii t
	       |`F_tt t]
      value funct = fun ~f -> f
    end
end | LFunct

Lo_prog116 =  
link spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end 
  spec Value = sig type t end
  spec IList2 = 
  ~Index ~Value ->
    sig
      type t
      value nil : t       
   end
  library IList2 = 
    struct type t = {} value nil = {} end
  spec rec Cat2IList2 = IList2 with {{Value = Cat2}}
  and Cat2 =
  ~Index ->
    sig
      type t
      value c_PP : ~lc:Cat2IList2.t -> t
      value c_BB : t
    end
  spec rec Funct2IList2 = IList2 with {{Value = Funct2}}
  and Funct2 =
  ~Cat2 ->
    sig
      type t
    end
  spec rec Trans2IList2 = IList2 with {{Value = Trans2}}
  and Trans2 =
  ~Funct2 ->
    sig
      type t
    end
  spec SemSSign =
  ~Trans2 ->
    sig
      value s_Pp : ~ls:Funct2IList2.t -> [`OK Funct2.t|`Error] 
      value s_Bb : ~lc:Cat2IList2.t ~lf:Funct2IList2.t -> Funct2.t
      value s_Ww : ~m1:Trans2.t ~s2:Funct2.t -> [`OK Funct2.t|`Error]
    end
  spec SemSDule =
  ~Trans2 ->
    sig
      value m_Id : ~s:Funct2.t -> Trans2.t
      value m_Comp : ~m1:Trans2.t ~m2:Trans2.t -> Trans2.t
      value m_Pr : ~lr:Funct2IList2.t ~i:Index.t ~s:Funct2.t -> 
	[`OK Trans2.t|`Error]
      value m_Record : ~r:Funct2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
        [`OK Trans2.t|`Error]
      value m_Base : ~r:Funct2.t ~s:Funct2.t 
	             ~lg:Funct2IList2.t ~lt:Trans2IList2.t ~lh:Funct2IList2.t ->
                       [`OK Trans2.t|`Error]
      value m_Inst : ~m1:Trans2.t ~m2:Trans2.t -> [`OK Trans2.t|`Error]
      value m_Cut : ~m1:Trans2.t ~r2:Funct2.t -> [`OK Trans2.t|`Error]
    end
  spec SemSLink =
  ~Trans2 ->
    sig
      value m_Accord : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
      value m_Concord : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
      value m_Link : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
    end
  spec SemSInd =
  ~Trans2 ->
    sig
      value m_Ind : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
    end
  spec rec SSignIList2 = IList2 with {{Value = SSign}}
  and SSign =
  ~Funct2IList2 ->
    sig
      type t
      value s_Pp : ~ls:SSignIList2.t -> t
      value s_Bb : ~lc:Cat2IList2.t ~lf:Funct2IList2.t -> t
      value s_Ww : ~m1:SDule.t ~s2:t -> t
      value el_sign : ~s:t -> [`OK Funct2.t|`Error]
    end
  and SDuleIList2 = IList2 with {{Value = SDule}}
  and SDule =
  ~Trans2IList2 ->
    sig
      type t
      value m_Id : ~s:SSign.t -> t
      value m_Comp : ~m1:t ~m2:t -> t
      value m_Pr : ~lr:SSignIList2.t ~i:Index.t -> t
      value m_Record : ~r:SSign.t ~lm:SDuleIList2.t -> t
      value m_Base : ~r:SSign.t ~s:SSign.t 
	             ~lg:Funct2IList2.t ~lt:Trans2IList2.t -> t
      value m_Inst : ~m1:t ~m2:t -> t
      value m_Cut : ~m1:t ~r2:SSign.t -> t
      value m_Accord : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value m_Concord : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value m_Link : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value m_Ind : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value el_dule : ~m:t -> [`OK {r : Funct2.t; 
				    s : Funct2.t; 
				    m : Trans2.t}
                              |`Error]
    end
  module ind SSignIList2 = load IList2 with {{Value = SSign}}
  and SSign = 
    struct
      type t = 
	ind t: [`S_Pp SSignIList2.t
	       |`S_Bb {lc : Cat2IList2.t; lf : Funct2IList2.t}
	       |`S_Ww {m1 : SDule.t; s2 : t}]
      value s_Pp = fun ~ls -> ls . `S_Pp . con
      value s_Bb = fun ~lc ~lf -> {lc; lf} . `S_Bb . con
      value s_Ww = fun ~m1 ~s2 -> {m1; s2} . `S_Ww . con
      value el_sign = fun ~s -> `Error
    end
  and SDuleIList2 = load IList2 with {{Value = SDule}}
  and SDule = 
    struct
      type t = 
        ind t: [`M_Id SSign.t
	       |`M_Comp {m1 : t; m2 : t}
	       |`M_Pr {lr : SSignIList2.t; i : Index.t}
	       |`M_Record {r : SSign.t; lm : SDuleIList2.t}
	       |`M_Base {r : SSign.t; s : SSign.t; 
			 lg : Funct2IList2.t; lt : Trans2IList2.t}
	       |`M_Inst {m1 : t; m2 : t}
	       |`M_Cut {m1 : t; r2 : SSign.t}
	       |`M_Accord {lr : SSignIList2.t; lm : SDuleIList2.t}
	       |`M_Concord {lr : SSignIList2.t; lm : SDuleIList2.t}
	       |`M_Link {lr : SSignIList2.t; lm : SDuleIList2.t}
	       |`M_Ind {lr : SSignIList2.t; lm : SDuleIList2.t}]
      value m_Id = fun ~s -> s .`M_Id . con
      value m_Comp = fun ~m1 ~m2 -> {m1; m2} .`M_Comp . con
      value m_Pr = fun ~lr ~i -> {lr; i} .`M_Pr . con
      value m_Record = fun ~r ~lm -> {r; lm} . `M_Record . con
      value m_Base = fun ~r ~s ~lg ~lt -> {r; s; lg; lt} .`M_Base . con
      value m_Inst = fun ~m1 ~m2 -> {m1; m2} .`M_Inst . con
      value m_Cut = fun ~m1 ~r2 -> {m1; r2} .`M_Cut . con
      value m_Accord = fun ~lr ~lm -> {lr; lm} .`M_Accord . con
      value m_Concord = fun ~lr ~lm -> {lr; lm} .`M_Concord . con
      value m_Link = fun ~lr ~lm -> {lr; lm} .`M_Link . con
      value m_Ind = fun ~lr ~lm -> {lr; lm} .`M_Ind . con
      value el_dule = fun ~m -> `Error
    end
end . SDule

Lo_prog117 =  
link
   spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end 
  spec Value = sig type t end 
  spec AssocIList13 = 
      ~Index ~Value ->
        sig
          type t
          value ind_ilist : ~l:t ->
            ind t: [`Nil|`Cons {i : Index.t; v : Value.t; l : t}]
          value nil : t
          value cons : ~i:Index.t ~v:Value.t ~l:t -> t
          value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
          value append : ~l1:t ~l13:t -> t
          value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
          value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
          value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
          value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
          value coi : ~ati:Value.t ~atj:Value.t -> t
        end
  spec IList13 = 
  ~Index ~Value ->
    sig
      type t
      value ind_ilist : ~l:t ->
        ind t: [`Nil|`Cons {i : Index.t; v : Value.t; l : t}]
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value append : ~l1:t ~l13:t -> t
      value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
      value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
      value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
      value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
   end
  library IList13 = 
        (:: AssocIList13
	struct
	  type t = {}
          value ind_ilist = fun ~l -> `Nil . con
  	  value nil = {}
          value cons = fun ~i ~v ~l -> {}
          value find_ok = fun ~i ~l -> `Error
          value append = fun ~l1 ~l13 -> {}
	  value bmap = fun ~f ~l -> {}
          value vmap = fun ~f ~l -> {}
          value imap = fun ~f ~l -> {}
          value ifilter = fun ~p ~l -> {}
          value coi = fun ~ati ~atj -> {}
	end) :> IList13
  ElabSDule =
link 
  spec IList13 = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
      value cons : ~i:Index.t ~v:Value.t ~l:t -> t
      value find_ok : ~i:Index.t ~l:t -> [`OK Value.t |`Error]
      value append : ~l1:t ~l13:t -> t
      value bmap : ~f: (~i:Index.t ~v:Value.t -> Value.t) ~l:t -> t
      value vmap : ~f: ~v:Value.t -> Value.t ~l:t -> t
      value imap : ~f: ~i:Index.t -> Value.t ~l:t -> t
      value ifilter : ~p: ~i:Index.t -> [`True|`False] ~l:t -> t
   end
  library IList131 = load IList13
  library IList13 = load IList131 :> IList13
  spec rec Cat13IList13 = IList13 with {{Value = Cat13}}
  and Cat13 =
  ~Index ->
    sig
      type t
      value c_PP : ~lc:Cat13IList13.t -> t
      value c_BB : t
    end
  spec rec Funct13IList13 = IList13 with {{Value = Funct13}}
  and Funct13 =
  ~Cat13 ->
    sig
      type t
    end
  spec rec Trans13IList13 = IList13 with {{Value = Trans13}}
  and Trans13 =
  ~Funct13 ->
    sig
      type t
    end
  spec SemSSign =
  ~Trans13 ->
    sig
      value s_Pp : ~ls:Funct13IList13.t -> [`OK Funct13.t|`Error] 
      value s_Bb : ~lc:Cat13IList13.t ~lf:Funct13IList13.t -> Funct13.t
      value s_Ww : ~m1:Trans13.t ~s13:Funct13.t -> [`OK Funct13.t|`Error]
    end
  spec SemSDule =
  ~Trans13 ->
    sig
      value m_Id : ~s:Funct13.t -> Trans13.t
      value m_Comp : ~m1:Trans13.t ~m13:Trans13.t -> Trans13.t
      value m_Pr : ~lr:Funct13IList13.t ~i:Index.t ~s:Funct13.t -> 
	[`OK Trans13.t|`Error]
      value m_Record : ~r:Funct13.t ~lm:Trans13IList13.t ~ls:Funct13IList13.t ->
        [`OK Trans13.t|`Error]
      value m_Base : ~r:Funct13.t ~s:Funct13.t 
	             ~lg:Funct13IList13.t ~lt:Trans13IList13.t ~lh:Funct13IList13.t ->
                       [`OK Trans13.t|`Error]
      value m_Inst : ~m1:Trans13.t ~m13:Trans13.t -> [`OK Trans13.t|`Error]
      value m_Cut : ~m1:Trans13.t ~r13:Funct13.t -> [`OK Trans13.t|`Error]
    end
  spec SemSLink =
  ~Trans13 ->
    sig
      value m_Accord : ~lr:Funct13IList13.t ~lm:Trans13IList13.t ~ls:Funct13IList13.t ->
	[`OK Trans13.t|`Error]
      value m_Concord : ~lr:Funct13IList13.t ~lm:Trans13IList13.t ~ls:Funct13IList13.t ->
	[`OK Trans13.t|`Error]
      value m_Link : ~lr:Funct13IList13.t ~lm:Trans13IList13.t ~ls:Funct13IList13.t ->
	[`OK Trans13.t|`Error]
    end
  spec SemSInd =
  ~Trans13 ->
    sig
      value m_Ind : ~lr:Funct13IList13.t ~lm:Trans13IList13.t ~ls:Funct13IList13.t ->
	[`OK Trans13.t|`Error]
    end
  spec rec SSignIList13 = IList13 with {{Value = SSign}}
  and SSign =
  ~Funct13IList13 ->
    sig
      type t
      value s_Pp : ~ls:SSignIList13.t -> t
      value s_Bb : ~lc:Cat13IList13.t ~lf:Funct13IList13.t -> t
      value s_Ww : ~m1:SDule.t ~s13:t -> t
      value el_sign : ~s:t -> [`OK Funct13.t|`Error]
    end
  and SDuleIList13 = IList13 with {{Value = SDule}}
  and SDule =
  ~Trans13IList13 ->
    sig
      type t
      value m_Id : ~s:SSign.t -> t
      value m_Comp : ~m1:t ~m13:t -> t
      value m_Pr : ~lr:SSignIList13.t ~i:Index.t -> t
      value m_Record : ~r:SSign.t ~lm:SDuleIList13.t -> t
      value m_Base : ~r:SSign.t ~s:SSign.t 
	             ~lg:Funct13IList13.t ~lt:Trans13IList13.t -> t
      value m_Inst : ~m1:t ~m13:t -> t
      value m_Cut : ~m1:t ~r13:SSign.t -> t
      value m_Accord : ~lr:SSignIList13.t ~lm:SDuleIList13.t -> t
      value m_Concord : ~lr:SSignIList13.t ~lm:SDuleIList13.t -> t
      value m_Link : ~lr:SSignIList13.t ~lm:SDuleIList13.t -> t
      value m_Ind : ~lr:SSignIList13.t ~lm:SDuleIList13.t -> t
      value el_dule : ~m:t -> [`OK {r : Funct13.t; 
				    s : Funct13.t; 
				    m : Trans13.t}
                              |`Error]
    end
  module ind SSignIList13 = load IList13 with {{Value = SSign}}
  and SSign = 
    struct
      type t = 
	ind t: [`S_Pp SSignIList13.t
	       |`S_Bb {lc : Cat13IList13.t; lf : Funct13IList13.t}
	       |`S_Ww {m1 : SDule.t; s13 : t}]
      value s_Pp = fun ~ls -> ls . `S_Pp . con
      value s_Bb = fun ~lc ~lf -> {lc; lf} . `S_Bb . con
      value s_Ww = fun ~m1 ~s13 -> {m1; s13} . `S_Ww . con
      value el_sign = fun ~s -> `Error
    end
  and SDuleIList13 = load IList13 with {{Value = SDule}}
  and SDule = 
    struct
      type t = 
        ind t: [`M_Id SSign.t
	       |`M_Comp {m1 : t; m13 : t}
	       |`M_Pr {lr : SSignIList13.t; i : Index.t}
	       |`M_Record {r : SSign.t; lm : SDuleIList13.t}
	       |`M_Base {r : SSign.t; s : SSign.t; 
			 lg : Funct13IList13.t; lt : Trans13IList13.t}
	       |`M_Inst {m1 : t; m13 : t}
	       |`M_Cut {m1 : t; r13 : SSign.t}
	       |`M_Accord {lr : SSignIList13.t; lm : SDuleIList13.t}
	       |`M_Concord {lr : SSignIList13.t; lm : SDuleIList13.t}
	       |`M_Link {lr : SSignIList13.t; lm : SDuleIList13.t}
	       |`M_Ind {lr : SSignIList13.t; lm : SDuleIList13.t}]
      value m_Id = fun ~s -> s .`M_Id . con
      value m_Comp = fun ~m1 ~m13 -> {m1; m13} .`M_Comp . con
      value m_Pr = fun ~lr ~i -> {lr; i} .`M_Pr . con
      value m_Record = fun ~r ~lm -> {r; lm} . `M_Record . con
      value m_Base = fun ~r ~s ~lg ~lt -> {r; s; lg; lt} .`M_Base . con
      value m_Inst = fun ~m1 ~m13 -> {m1; m13} .`M_Inst . con
      value m_Cut = fun ~m1 ~r13 -> {m1; r13} .`M_Cut . con
      value m_Accord = fun ~lr ~lm -> {lr; lm} .`M_Accord . con
      value m_Concord = fun ~lr ~lm -> {lr; lm} .`M_Concord . con
      value m_Link = fun ~lr ~lm -> {lr; lm} .`M_Link . con
      value m_Ind = fun ~lr ~lm -> {lr; lm} .`M_Ind . con
      value el_dule = fun ~m -> `Error
    end
end
end | ElabSDule | SDuleIList13

Lo_prog118 =  
link
   spec Index =
    sig
      type t
      value eq : ~i:t ~j:t -> [`True|`False]
      value isDU : ~i:t -> [`True|`False]
      value up : t
      value it : t
      value ati : t
      value atj : t
      value att : t
      value atv : t
      value prim : ~i:t -> t
    end 
  spec Value = sig type t end 
  spec AssocIList2 = 
      ~Index ~Value ->
        sig
          type t
          value nil : t
        end
  spec IList2 = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList2 = 
        (:: AssocIList2
	struct
	  type t = {}
  	  value nil = {}
	end) :> IList2
  ElabSDule =
link 
  spec IList2 = 
  ~Index ~Value ->
    sig
      type t
      value nil : t
   end
  library IList2_SDule = load IList2 :> IList2
  spec rec Cat2IList2 = IList2 with {{Value = Cat2}}
  and Cat2 =
  ~Index ->
    sig
      type t
      value c_PP : ~lc:Cat2IList2.t -> t
      value c_BB : t
    end
  spec rec Funct2IList2 = IList2 with {{Value = Funct2}}
  and Funct2 =
  ~Cat2 ->
    sig
      type t
    end
  spec rec Trans2IList2 = IList2 with {{Value = Trans2}}
  and Trans2 =
  ~Funct2 ->
    sig
      type t
    end
  spec SemSSign =
  ~Trans2 ->
    sig
      value s_Pp : ~ls:Funct2IList2.t -> [`OK Funct2.t|`Error] 
      value s_Bb : ~lc:Cat2IList2.t ~lf:Funct2IList2.t -> Funct2.t
      value s_Ww : ~m1:Trans2.t ~s2:Funct2.t -> [`OK Funct2.t|`Error]
    end
  spec SemSDule =
  ~Trans2 ->
    sig
      value m_Id : ~s:Funct2.t -> Trans2.t
      value m_Comp : ~m1:Trans2.t ~m2:Trans2.t -> Trans2.t
      value m_Pr : ~lr:Funct2IList2.t ~i:Index.t ~s:Funct2.t -> 
	[`OK Trans2.t|`Error]
      value m_Record : ~r:Funct2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
        [`OK Trans2.t|`Error]
      value m_Base : ~r:Funct2.t ~s:Funct2.t 
	             ~lg:Funct2IList2.t ~lt:Trans2IList2.t ~lh:Funct2IList2.t ->
                       [`OK Trans2.t|`Error]
      value m_Inst : ~m1:Trans2.t ~m2:Trans2.t -> [`OK Trans2.t|`Error]
      value m_Cut : ~m1:Trans2.t ~r2:Funct2.t -> [`OK Trans2.t|`Error]
    end
  spec SemSLink =
  ~Trans2 ->
    sig
      value m_Accord : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
      value m_Concord : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
      value m_Link : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
    end
  spec SemSInd =
  ~Trans2 ->
    sig
      value m_Ind : ~lr:Funct2IList2.t ~lm:Trans2IList2.t ~ls:Funct2IList2.t ->
	[`OK Trans2.t|`Error]
    end
  spec rec SSignIList2 = IList2 with {{Value = SSign}}
  and SSign =
  ~Funct2IList2 ->
    sig
      type t
      value s_Pp : ~ls:SSignIList2.t -> t
      value s_Bb : ~lc:Cat2IList2.t ~lf:Funct2IList2.t -> t
      value s_Ww : ~m1:SDule.t ~s2:t -> t
      value el_sign : ~s:t -> [`OK Funct2.t|`Error]
    end
  and SDuleIList2 = IList2 with {{Value = SDule}}
  and SDule =
  ~Trans2IList2 ->
    sig
      type t
      value m_Id : ~s:SSign.t -> t
      value m_Comp : ~m1:t ~m2:t -> t
      value m_Pr : ~lr:SSignIList2.t ~i:Index.t -> t
      value m_Record : ~r:SSign.t ~lm:SDuleIList2.t -> t
      value m_Base : ~r:SSign.t ~s:SSign.t 
	             ~lg:Funct2IList2.t ~lt:Trans2IList2.t -> t
      value m_Inst : ~m1:t ~m2:t -> t
      value m_Cut : ~m1:t ~r2:SSign.t -> t
      value m_Accord : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value m_Concord : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value m_Link : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value m_Ind : ~lr:SSignIList2.t ~lm:SDuleIList2.t -> t
      value el_dule : ~m:t -> [`OK {r : Funct2.t; 
				    s : Funct2.t; 
				    m : Trans2.t}
                              |`Error]
    end
  module ind SSignIList2 = load IList2_SDule with {{Value = SSign}}
  and SSign = 
    struct
      type t = 
	ind t: [`S_Pp SSignIList2.t
	       |`S_Bb {lc : Cat2IList2.t; lf : Funct2IList2.t}
	       |`S_Ww {m1 : SDule.t; s2 : t}]
      value s_Pp = fun ~ls -> ls . `S_Pp . con
      value s_Bb = fun ~lc ~lf -> {lc; lf} . `S_Bb . con
      value s_Ww = fun ~m1 ~s2 -> {m1; s2} . `S_Ww . con
      value el_sign = fun ~s -> `Error
    end
  and SDuleIList2 = load IList2_SDule with {{Value = SDule}}
  and SDule = 
    struct
      type t = 
        ind t: [`M_Id SSign.t
	       |`M_Comp {m1 : t; m2 : t}
	       |`M_Pr {lr : SSignIList2.t; i : Index.t}
	       |`M_Record {r : SSign.t; lm : SDuleIList2.t}
	       |`M_Base {r : SSign.t; s : SSign.t; 
			 lg : Funct2IList2.t; lt : Trans2IList2.t}
	       |`M_Inst {m1 : t; m2 : t}
	       |`M_Cut {m1 : t; r2 : SSign.t}
	       |`M_Accord {lr : SSignIList2.t; lm : SDuleIList2.t}
	       |`M_Concord {lr : SSignIList2.t; lm : SDuleIList2.t}
	       |`M_Link {lr : SSignIList2.t; lm : SDuleIList2.t}
	       |`M_Ind {lr : SSignIList2.t; lm : SDuleIList2.t}]
      value m_Id = fun ~s -> s .`M_Id . con
      value m_Comp = fun ~m1 ~m2 -> {m1; m2} .`M_Comp . con
      value m_Pr = fun ~lr ~i -> {lr; i} .`M_Pr . con
      value m_Record = fun ~r ~lm -> {r; lm} . `M_Record . con
      value m_Base = fun ~r ~s ~lg ~lt -> {r; s; lg; lt} .`M_Base . con
      value m_Inst = fun ~m1 ~m2 -> {m1; m2} .`M_Inst . con
      value m_Cut = fun ~m1 ~r2 -> {m1; r2} .`M_Cut . con
      value m_Accord = fun ~lr ~lm -> {lr; lm} .`M_Accord . con
      value m_Concord = fun ~lr ~lm -> {lr; lm} .`M_Concord . con
      value m_Link = fun ~lr ~lm -> {lr; lm} .`M_Link . con
      value m_Ind = fun ~lr ~lm -> {lr; lm} .`M_Ind . con
      value el_dule = fun ~m -> `Error
    end
end
end . ElabSDule . SSign

Lo_IndSyntax1 =
link
  spec Nat =
    sig
      type t
      value zero : t
      value one : t 
      value plus : ~n:t ~m:t -> t
      value pred : ~n:t -> t
    end
  Nat = 
    struct
      type t = ind nat: [`Zero|`Succ nat]
      value zero = `Zero . con
      value one = `Zero . con .`Succ . con
      value plus = fun ~m ~n -> 
        match n with
        fold [`Zero -> m
             |`Succ nn -> nn .`Succ . con]
      value pred = fun ~n ->
        match n . de with
        [`Zero -> `Zero . con
        |`Succ nn -> nn]
    end
  spec Syntax =
  ~Nat -> 
    sig
      type exp
      value test : {test_4 : Nat.t;
                    test_3 : Nat.t;
                    test_1 : Nat.t}
    end
  SyntaxIndInd =
    :: Syntax
    struct
      type exp = 
        ind exp: {location : Nat.t;
                  code : [`Do ind ins: [`Ignore exp
                                       |`Seq {i1 : ins;
                                              i2 : ins}]
                         |`Const Nat.t]}
      value test =
        let exp2 = {location = Nat.zero;
                    code = Nat.zero . `Const} . con
            exp0 = {location = Nat.one;
                    code = Nat.zero . `Const} . con 
            exp1 = {location = Nat.one;
                    code = Nat.one . `Const} . con in
        let program =
          {location = Nat.one;
           code = {i1 = exp0 .`Ignore . con;
                   i2 = {i1 = exp1 .`Ignore . con;
                         i2 = exp2 .`Ignore . con} .`Seq . con}
            .`Seq . con .`Do} . con 
            . : ind exp: {location : Nat.t;
                          code : [`Do ind ins: [`Ignore exp
                                               |`Seq {i1 : ins;
                                                      i2 : ins}]
                                 |`Const Nat.t]}
            sum_all = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do fold [`Ignore n -> n
                         |`Seq i1xi2 -> 
                            Nat.plus ~n:i1xi2.i1 ~m:i1xi2.i1]
               |`Const n -> n]
            sum_loc = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do fold [`Ignore n -> n
                         |`Seq i1xi2 -> 
                            Nat.plus ~n:i1xi2.i1 ~m:i1xi2.i2]
               |`Const n -> Nat.zero]
            sum_con = fun ~it ->
          (match it.code with
          [`Do fold [`Ignore n -> n
                    |`Seq i1xi2 -> 
                       Nat.plus ~n:i1xi2.i2 ~m:i1xi2.i2]
          |`Const n -> n])
        in
        {test_4 = match program with
                  fold sum_all;
         test_3 = match program with
                  fold sum_loc;
         test_1 = match program with
                  fold sum_con}
    end
  SyntaxIndCoind =
    :: Syntax
    struct
      type exp = 
        ind exp: {location : Nat.t;
                  code : [`Do coind ins: [`Ignore exp
                                         |`Seq {i1 : ins;
                                                i2 : ins}]
                         |`Const Nat.t]}
      value test =
        let exp1 = {location = Nat.zero;
                    code = Nat.zero . `Const} . con
            exp2 = {location = Nat.one;
                    code = Nat.zero . `Const} . con 
            exp0 = {location = Nat.one;
                    code = Nat.one . `Const} . con in
        let program =
          {location = Nat.one;
           code = {i1 = exp0 .`Ignore . uncon;
                   i2 = {i1 = exp1 .`Ignore . uncon;
                         i2 = exp2 .`Ignore . uncon} .`Seq . uncon}
            .`Seq . uncon .`Do} . con 
            . : ind exp: {location : Nat.t;
                          code : [`Do coind ins: [`Ignore exp
                                                 |`Seq {i1 : ins;
                                                        i2 : ins}]
                                 |`Const Nat.t]}
            sum_all = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do
                  let rec fi = fun ~it ->
                    match it . unde with
                    [`Ignore n -> n
                    |`Seq i1xi2 ->  
                       Nat.plus ~n:(fi ~it:i1xi2.i1) ~m:(fi ~it:i1xi2.i2)]
                  in fi
               |`Const n -> n]
            sum_shallow = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do -> Nat.one
               |`Const n -> n]
            sum_221 = fun ~it ->
          (match it.code with
          [`Do i ->
             let rec fi = fun ~i ->
               match i . unde with
              [`Ignore n -> n
              |`Seq i1xi2 ->  
                 Nat.plus ~n:(fi ~i:i1xi2.i2) ~m:(fi ~i:i1xi2.i2)]
             in Nat.pred ~n:(fi ~i)
          |`Const n -> n])
        in
        {test_4 = match program with
                  fold sum_all;
         test_1 = match program with
                  fold sum_shallow;
         test_3 = match program with
                  fold sum_221}
    end
end . SyntaxIndInd

Lo_IndSyntax2 =
link
  spec Nat =
    sig
      type t
      value zero : t
      value one : t 
      value plus : ~n:t ~m:t -> t
      value pred : ~n:t -> t
    end
  Nat = 
    struct
      type t = ind nat: [`Zero|`Succ nat]
      value zero = `Zero . con
      value one = `Zero . con .`Succ . con
      value plus = fun ~m ~n -> 
        match n with
        fold [`Zero -> m
             |`Succ nn -> nn .`Succ . con]
      value pred = fun ~n ->
        match n . de with
        [`Zero -> `Zero . con
        |`Succ nn -> nn]
    end
  spec Syntax =
  ~Nat -> 
    sig
      type exp
      value test : {test_4 : Nat.t;
                    test_3 : Nat.t;
                    test_1 : Nat.t}
    end
  SyntaxIndInd =
    :: Syntax
    struct
      type exp = 
        ind exp: {location : Nat.t;
                  code : [`Do ind ins: [`Ignore exp
                                       |`Seq {i1 : ins;
                                              i2 : ins}]
                         |`Const Nat.t]}
      value test =
        let program =
          {location = Nat.zero;
           code = {i1 = {location = Nat.zero;
                    code = Nat.zero . `Const} . con .`Ignore . con;
                   i2 = {i1 = {location = Nat.one;
                    code = Nat.one . `Const} . con .`Ignore . con;
                         i2 = {location = Nat.one;
                    code = Nat.zero . `Const} . con .`Ignore . con} .`Seq . con}
            .`Seq . con .`Do} . con 
            sum_all = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do fold [`Ignore n -> n
                         |`Seq i1xi2 -> 
                            Nat.plus ~n:i1xi2.i1 ~m:i1xi2.i2]
               |`Const n -> n]
            sum_loc = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do fold [`Ignore n -> n
                         |`Seq i1xi2 -> 
                            Nat.plus ~n:i1xi2.i2 ~m:i1xi2.i2]
               |`Const n -> Nat.zero]
            sum_con = fun ~it ->
          (match it.code with
          [`Do fold [`Ignore n -> n
                    |`Seq i1xi2 -> 
                       Nat.plus ~n:i1xi2.i1 ~m:i1xi2.i2]
          |`Const n -> n])
        in
        {test_4 = match program with
                  fold sum_all;
         test_3 = match program with
                  fold sum_loc;
         test_1 = match program with
                  fold sum_con}
    end
  SyntaxIndCoind =
    :: Syntax
    struct
      type exp = 
        ind exp: {location : Nat.t;
                  code : [`Do coind ins: [`Ignore exp
                                         |`Seq {i1 : ins;
                                                i2 : ins}]
                         |`Const Nat.t]}
      value test =
        let program =
          {location = Nat.one;
           code = {i1 = {location = Nat.zero;
                    code = Nat.one . `Const} . con .`Ignore . uncon;
                   i2 = {i1 = {location = Nat.zero;
                    code = Nat.zero . `Const} . con .`Ignore . uncon;
                         i2 = {location = Nat.one;
                    code = Nat.one . `Const} . con .`Ignore . uncon} .`Seq . uncon}
            .`Seq . uncon .`Do} . con 
            sum_all = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do
                  let rec fi = fun ~it ->
                    match it . unde with
                    [`Ignore n -> n
                    |`Seq i1xi2 ->  
                       Nat.plus ~n:(fi ~it:i1xi2.i1) ~m:(fi ~it:i1xi2.i2)]
                  in fi
               |`Const n -> n]
            sum_shallow = fun ~it ->
          Nat.plus ~n:it.location
            ~m:match it.code with
               [`Do -> Nat.zero
               |`Const n -> n]
            sum_221 = fun ~it ->
          (match it.code with
          [`Do i ->
             let rec fi = fun ~i ->
               match i . unde with
              [`Ignore n -> n
              |`Seq i1xi2 ->  
                 Nat.plus ~n:(fi ~i:i1xi2.i1) ~m:(fi ~i:i1xi2.i2)]
             in Nat.pred ~n:(fi ~i)
          |`Const n -> n])
        in
        {test_4 = match program with
                  fold sum_all;
         test_1 = match program with
                  fold sum_shallow;
         test_3 = match program with
                  fold sum_221}
    end
end | SyntaxIndCoind

Lo_OldPrelude =
link
spec Bool =
  sig
    value tt : [`True|`False]
    value ff : [`True|`False]
    value neg : ~it:[`True|`False] -> [`True|`False] 
    value conj : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False] 
    value disj : ~b:[`True|`False] ~it:[`True|`False] -> [`True|`False]
  end
library Bool = 
  struct
    value tt = `True
    value ff = `False
    value neg = [`True -> `False
                |`False -> `True]
    value conj = [`True fun ~b ~it -> b
                 |`False fun ~b ~it -> `False]
    value disj = [`True fun ~b ~it -> `True
                 |`False fun ~b ~it -> b]
  end
spec Nat =
  sig
    type t
    value t2ind : ~n:t -> ind nat: [`Zero|`Succ nat]
    value tde : ~n:t -> [`Zero|`Succ t]
    value zero : t
    value succ : ~n:t -> t
    value pred : ~n:t -> t
    value add : ~n:t ~it:t -> t
    value mult : ~n:t ~it:t -> t
    value sub : ~n:t ~it:t -> t
    value is_zero : ~it:t -> [`True|`False]
    value leq : ~n:t ~it:t -> [`True|`False]
    value eq : ~n:t ~it:t -> [`True|`False]
  end
library Nat = 
link
  spec NatPlus =
    sig
      type t
      value t2ind : ~n:t -> ind nat: [`Zero|`Succ nat]
      value tde : ~n:t -> [`Zero|`Succ t]
      value zero : t
      value succ : ~n:t -> t
      value pred : ~n:t -> t
      value add : ~n:t ~it:t -> t
      value is_zero : ~it:t -> [`True|`False]
    end
  NatPlus = 
    struct
      type t = ind nat: [`Zero|`Succ nat]
      value t2ind = fun ~n -> n
      value tde = fun ~n -> n . de
      value zero = `Zero . con
      value succ = fun ~n -> n .`Succ . con
      value pred = fun ~n ->
        match n . de with
        [`Zero -> n
        |`Succ nn -> nn]
      value add = fun ~n ~it -> 
        match n with
        fold [`Zero -> it
             |`Succ nn -> nn .`Succ . con]
      value is_zero = fun ~it ->
        match it . de with
        [`Zero -> `True
        |`Succ -> `False]
    end
  spec NatTimes =
  ~NatPlus ->
    sig
      value mult : NatPlus . ~n:t ~it:t -> t
      value sub : NatPlus . ~n:t ~it:t -> t
    end
  NatTimes =
    struct
      value mult = NatPlus . fun ~n ~it ->
        match t2ind ~n with
        fold [`Zero -> zero
             |`Succ n -> add ~n ~it]
      value sub = NatPlus . fun ~n ~it ->
        match t2ind ~n:it with
        fold [`Zero -> n
             |`Succ n -> pred ~n]
    end
  spec NatLeq =
  ~NatTimes ->
    sig
      value leq : ~n:NatPlus.t ~it:NatPlus.t -> [`True|`False]
    end
  NatLeq =
    struct
      value leq = fun ~n ~it ->
        NatPlus.is_zero ~it:(NatTimes.sub ~n ~it)
    end
  NatAll =
    :: ~NatLeq -> Nat
    struct
      type t = NatPlus.t
      value t2ind = NatPlus.t2ind
      value tde = NatPlus.tde
      value zero = NatPlus.zero
      value succ = NatPlus.succ
      value pred = NatPlus.pred
      value add = NatPlus.add
      value mult = NatTimes.mult
      value sub = NatTimes.sub
      value is_zero = NatPlus.is_zero
      value leq = NatLeq.leq
      value eq = NatLeq . fun ~n ~it ->
        match leq ~n ~it with
        [`True -> leq ~n:it ~it:n
        |`False -> `False]
    end
end | NatAll
spec Char =
  sig 
    type t
    value tde : ~c:t -> [`a|`b|`c
                        |`A|`B|`C
                        |`quote]
    value c_a : t
    value c_b : t
    value c_c : t
    value c_A : t
    value c_B : t
    value c_C : t
    value eq : ~c:t ~it:t -> [`True|`False]
    value is_upper : ~it:t -> [`True|`False]
    value c_quote : t
    value upper : ~it:t -> t
    value lower : ~it:t -> t
  end
library Char =
  struct
    type t = [`a|`b|`c
             |`A|`B|`C
             |`quote]
    value tde = fun ~c -> c
    value c_a = `a
    value c_b = `b
    value c_c = `c
    value c_A = `A
    value c_B = `B
    value c_C = `C
    value c_quote = `quote
    value eq =
      let tt  = `True
          ff = `False 
      in 
      [`a fun ~c ~it -> match c with 
        [`a -> tt|`b -> ff|`c -> ff
        |`A -> ff|`B -> ff|`C -> ff
        |`quote -> ff]
      |`b fun ~c ~it -> match c with 
        [`a -> ff|`b -> tt|`c -> ff
        |`A -> ff|`B -> ff|`C -> ff
        |`quote -> ff]
      |`c fun ~c ~it -> match c with 
        [`a -> ff|`b -> ff|`c -> tt
        |`A -> ff|`B -> ff|`C -> ff
        |`quote -> ff]
      |`A fun ~c ~it -> match c with
        [`a -> ff|`b -> ff|`c -> ff
        |`A -> tt|`B -> ff|`C -> ff
        |`quote -> ff]
      |`B fun ~c ~it -> match c with
        [`B -> tt|_ -> ff]
      |`C fun ~c ~it -> match c with
        [`C -> tt
        |_ -> ff]
      |`quote fun ~c ~it -> match c with
        [_ -> ff
        |`quote -> tt]
      ]
    value is_upper = [_ -> `False
                     |`A -> `True |`B -> `True |`C -> `True]
    value upper = [`a -> `A|`b -> `B|`c -> `C
                  |`A -> `A|`B -> `B|`C -> `C
                  |`quote -> `quote]
    value lower = [`a -> `a|`b -> `b|`c -> `c
                  |`A -> `a|`B -> `b|`C -> `c
                  |`quote -> `quote]
  end
spec Elem = sig type t end
spec List = 
~Elem ->
  sig
    type t
    value t2ind : ~l:t -> ind list: [`Nil|`Cons {head : Elem.t; tail : list}]
    value ind2t : ~l:ind list: [`Nil|`Cons {head : Elem.t; tail : list}] -> t
    value tde : ~l:t -> [`Nil|`Cons {head : Elem.t; tail : t}]
    value nil : t
    value cons : ~head:Elem.t ~tail:t -> t
  end
library List =
  struct
    type t = ind list: [`Nil|`Cons {head : Elem.t; tail : list}]
    value t2ind = fun ~l -> l
    value ind2t = fun ~l -> l
    value tde = fun ~l -> l . de
    value nil = `Nil . con
    value cons = fun ~head ~tail -> {head; tail} .`Cons . con
  end
spec ListOps =
~List ->
  sig
    value append : List . ~l1:t ~l2:t -> t 
    value is_nil : ~l:List.t -> [`True|`False]
    value endo_map : ~f: ~it:Elem.t -> Elem.t ~l:List.t -> List.t 
  end
library ListOps =
  struct
    value append = fun ~l1 ~l2 ->
      match List.t2ind ~l:l1 with
      fold [`Nil -> l2
           |`Cons ht -> List.cons ~head:ht.head ~tail:ht.tail]
    value is_nil = fun ~l -> 
      match List.tde ~l with
      [`Nil -> `True
      |`Cons -> `False]
    value endo_map = fun ~f ~l -> 
      List.ind2t 
        ~l:(match List.t2ind ~l with
            map f)
  end
spec CharList = List with {Elem = Char}
library CharList = load List with {Elem = Char}
spec CharListOps = ListOps with {Elem = Char; List = CharList}
library CharListOps = load ListOps with {Elem = Char; List = CharList}
spec String =
~CharList ->
  sig
    value eq : ~l:CharList.t ~it:CharList.t -> [`True|`False]
    value atu : CharList.t
    value it : CharList.t
    value a : Char.t
    value prefix_by_a : CharList . ~tail:t -> t
    value append : CharList . ~l1:t ~l2:t -> t 
    value shout : CharList . ~it:t -> t
  end
library String' = 
  :: ~Bool ~CharListOps -> String
  struct
    value eq =
      let non_nil_eq = fun ~it -> fun ~l -> 
        match CharList.tde ~l with
        [`Nil -> Bool.ff
        |`Cons lht ->
           let head_matches = Char.eq ~c:it.head ~it:lht.head
               tail_equal = it.tail ~l:lht.tail in
           Bool.conj ~b:head_matches ~it:tail_equal]
      in
      fun ~l ~it -> 
        (match CharList.t2ind ~l:it with
         fold [`Nil -> CharListOps.is_nil
              |`Cons non_nil_eq]) ~l
    value atu = CharList.cons ~head:Char.c_c 
                  ~tail:(CharList.cons ~head:Char.c_a 
                           ~tail:(CharList.cons ~head:Char.c_b
                                    ~tail:CharList.nil))
    value it = CharList.cons ~head:Char.c_a 
                 ~tail:(CharList.cons ~head:Char.c_b
                          ~tail:CharList.nil)
    value a = Char.c_a
    value prefix_by_a = fun ~tail -> 
      CharList.cons ~head:Char.c_a ~tail
    value append = CharListOps.append
    value shout = fun ~it -> 
      CharListOps.endo_map ~l:it ~f:Char.upper
  end
library String = 
  (load String' with {{Bool; CharListOps = load CharListOps}}) :> String

(* The loads below are for testing and compilation with [-c]. *)
Bool = load Bool
Nat = load Nat
Char = load Char
CharList = load CharList
CharListOps = load CharListOps
String = load String
end|String
